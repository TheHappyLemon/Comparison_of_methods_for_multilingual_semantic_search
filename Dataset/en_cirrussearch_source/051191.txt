Optimal solutions for the Rubik's Cube are solutions that are the shortest in some sense. There are two common ways to measure the length of a solution. The first is to count the number of quarter turns. The second is to count the number of outer-layer twists, called "face turns". A move to turn an outer layer two quarter (90°) turns in the same direction would be counted as two moves in the quarter turn metric (QTM), but as one turn in the face metric (FTM, or HTM "Half Turn Metric", or OBTM "Outer Block Turn Metric"). The maximal number of face turns needed to solve any instance of the Rubik's Cube is 20, and the maximal number of quarter turns is 26. These numbers are also the diameters of the corresponding Cayley graphs of the Rubik's Cube group. In STM (slice turn metric), the minimal number of turns is unknown. There are many algorithms to solve scrambled Rubik's Cubes. An algorithm that solves a cube in the minimum number of moves is known as God's algorithm. To denote a sequence of moves on the 3×3×3 Rubik's Cube, this article uses "Singmaster notation", which was developed by David Singmaster. The following are standard moves, which do not move centre cubies of any face to another location: The letters L, R, F, B, U, and D indicate a clockwise quarter turn of the left, right, front, back, up, and down face respectively. A half turn (i.e. 2 quarter turns in the same direction) are indicated by appending a 2. A counterclockwise turn is indicated by appending a prime symbol ( ′ ). However, because these notations are human-oriented, we use clockwise as positive, and not mathematically-oriented, which is counterclockwise as positive. The following are non-standard moves Non-standard moves are usually represented with lowercase letters in contrast to the standard moves above. Moving centre cubies of faces to other locations: The letters M, S and E are used to denote the turning of a middle layer. M (short for "Middle" layer) represents turning the layer between the R and L faces 1 quarter turn clockwise (front to back), as seen facing the L face. S (short for "Standing" layer) represents turning the layer between the F and B faces 1 quarter turn clockwise (top to bottom), as seen facing the F face. E (short for "Equator" layer) represents turning the layer between the U and D faces 1 quarter turn clockwise (left to right), as seen from the D face. As with regular turns, a 2 signifies a half turn and a prime (') indicates a turn counterclockwise. Instead, lowercase letters r, f and u are also used to denote turning layers next to R, F and U respectively in the same direction as R, F and U. This is more consistent with expectations. In multiple-layer cubes, numbers may precede face names to indicate rotation of the nth layer from the named face. 2R, 2F and 2U are then used to denote turning layers next to R, F and U respectively in the same direction as R, F and U. Using this notation for a three-layer cube is more consistent with multiple-layer cubes. Rotating the whole cube: The letters x, y and z are used to signify cube rotations. x signifies rotating the cube in the R direction. y signifies the rotation of the cube in the U direction. z signifies the rotation of the cube on the F direction. These cube rotations are often used in algorithms to make them smoother and faster. As with regular turns, a 2 signifies a half turn and a prime (') indicates a turn counterclockwise. Note that these spacial rotations are usually represented with lowercase letters. It can be proven by counting arguments that there exist positions needing at least 18 moves to solve. To show this, first count the number of cube positions that exist in total, then count the number of positions achievable using at most 17 moves starting from a solved cube. It turns out that the latter number is smaller. This argument was not improved upon for many years. Also, it is not a constructive proof: it does not exhibit a concrete position that needs this many moves. It was conjectured that the so-called superflip would be a position that is very difficult. A Rubik's Cube is in the superflip pattern when each corner piece is in the correct position, but each edge piece is incorrectly oriented. In 1992, a solution for the superflip with 20 face turns was found by Dik T. Winter, of which the minimality was shown in 1995 by Michael Reid, providing a new lower bound for the diameter of the cube group. Also in 1995, a solution for superflip in 24 quarter turns was found by Michael Reid, with its minimality proven by Jerry Bryan. In 1998, a new position requiring more than 24 quarter turns to solve was found. The position, which was called a 'superflip composed with four spot' needs 26 quarter turns. The first upper bounds were based on the 'human' algorithms. By combining the worst-case scenarios for each part of these algorithms, the typical upper bound was found to be around 100. Perhaps the first concrete value for an upper bound was the 277 moves mentioned by David Singmaster in early 1979. He simply counted the maximum number of moves required by his cube-solving algorithm. Later, Singmaster reported that Elwyn Berlekamp, John Conway, and Richard K. Guy had come up with a different algorithm that took at most 160 moves. Soon after, Conway’s Cambridge Cubists reported that the cube could be restored in at most 94 moves. The breakthrough, known as "descent through nested sub-groups" was found by Morwen Thistlethwaite; details of Thistlethwaite's algorithm were published in Scientific American in 1981 by Douglas Hofstadter. The approaches to the cube that led to algorithms with very few moves are based on group theory and on extensive computer searches. Thistlethwaite's idea was to divide the problem into subproblems. Where algorithms up to that point divided the problem by looking at the parts of the cube that should remain fixed, he divided it by restricting the type of moves that could be executed. In particular he divided the cube group into the following chain of subgroups: G0=⟨L,R,F,B,U,D⟩{\displaystyle G_{0}=\langle L,R,F,B,U,D\rangle } G1=⟨L,R,F,B,U2,D2⟩{\displaystyle G_{1}=\langle L,R,F,B,U^{2},D^{2}\rangle } G2=⟨L,R,F2,B2,U2,D2⟩{\displaystyle G_{2}=\langle L,R,F^{2},B^{2},U^{2},D^{2}\rangle } G3=⟨L2,R2,F2,B2,U2,D2⟩{\displaystyle G_{3}=\langle L^{2},R^{2},F^{2},B^{2},U^{2},D^{2}\rangle } G4={1}{\displaystyle G_{4}=\{1\}} Next he prepared tables for each of the right coset spaces Gi+1∖Gi{\displaystyle G_{i+1}\setminus G_{i}}. For each element he found a sequence of moves that took it to the next smaller group. After these preparations he worked as follows. A random cube is in the general cube group G0{\displaystyle G_{0}}. Next he found this element in the right coset space G1∖G0{\displaystyle G_{1}\setminus G_{0}}. He applied the corresponding process to the cube. This took it to a cube in G1{\displaystyle G_{1}}. Next he looked up a process that takes the cube to G2{\displaystyle G_{2}}, next to G3{\displaystyle G_{3}} and finally to G4{\displaystyle G_{4}}. Although the whole cube group G0{\displaystyle G_{0}} is very large (~4.3×1019), the right coset spaces G1∖G0,G2∖G1,G3∖G2{\displaystyle G_{1}\setminus G_{0},G_{2}\setminus G_{1},G_{3}\setminus G_{2}} and G3{\displaystyle G_{3}} are much smaller. The coset space G2∖G1{\displaystyle G_{2}\setminus G_{1}} is the largest and contains only 1082565 elements. The number of moves required by this algorithm is the sum of the largest process in each step. Initially, Thistlethwaite showed that any configuration could be solved in at most 85 moves. In January 1980 he improved his strategy to yield a maximum of 80 moves. Later that same year, he reduced the number to 63, and then again to 52. By exhaustively searching the coset spaces it was later found that the worst possible number of moves for each stage was 7, 10, 13, and 15 giving a total of 45 moves at most. There have been implementations of Thistlewaite's algorithm in various computer languages. Thistlethwaite's algorithm was improved by Herbert Kociemba in 1992. He reduced the number of intermediate groups to only two: G0=⟨U,D,L,R,F,B⟩{\displaystyle G_{0}=\langle U,D,L,R,F,B\rangle } G1=⟨U,D,L2,R2,F2,B2⟩{\displaystyle G_{1}=\langle U,D,L^{2},R^{2},F^{2},B^{2}\rangle } G2={1}{\displaystyle G_{2}=\{1\}} As with Thistlethwaite's algorithm, he would search through the right coset space G1∖G0{\displaystyle G_{1}\setminus G_{0}} to take the cube to group G1{\displaystyle G_{1}}. Next he searched the optimal solution for group G1{\displaystyle G_{1}}. The searches in G1∖G0{\displaystyle G_{1}\setminus G_{0}} and G1{\displaystyle G_{1}} were both done with a method equivalent to iterative deepening A* (IDA*). The search in G1∖G0{\displaystyle G_{1}\setminus G_{0}} needs at most 12 moves and the search in G1{\displaystyle G_{1}} at most 18 moves, as Michael Reid showed in 1995. By also generating suboptimal solutions that take the cube to group G1{\displaystyle G_{1}} and looking for short solutions in G1{\displaystyle G_{1}}, much shorter overall solutions are usually obtained. Using this algorithm solutions are typically found of fewer than 21 moves, though there is no proof that it will always do so. In 1995 Michael Reid proved that using these two groups every position can be solved in at most 29 face turns, or in 42 quarter turns. This result was improved by Silviu Radu in 2005 to 40. At first glance, this algorithm appears to be practically inefficient: if G0{\displaystyle G_{0}}contains 18 possible moves (each move, its prime, and its 180-degree rotation), that leaves 1812{\displaystyle 18^{12}} (over 1 quadrillion) cube states to be searched. Even with a heuristic-based computer algorithm like IDA*, which may narrow it down considerably, searching through that many states is likely not practical. To solve this problem, Kociemba devised a lookup table that provides an exact heuristic for G0{\displaystyle G_{0}}. When the exact number of moves needed to reach G1{\displaystyle G_{1}}is available, the search becomes virtually instantaneous: one need only generate 18 cube states for each of the 12 moves and choose the one with the lowest heuristic each time. This allows the second heuristic, that for G1{\displaystyle G_{1}}, to be less precise and still allow for a solution to be computed in reasonable time on a modern computer. Using these group solutions combined with computer searches will generally quickly give very short solutions. But these solutions do not always come with a guarantee of their minimality. To search specifically for minimal solutions a new approach was needed. In 1997 Richard Korf announced an algorithm with which he had optimally solved random instances of the cube. Of the ten random cubes he did, none required more than 18 face turns. The method he used is called IDA* and is described in his paper "Finding Optimal Solutions to Rubik's Cube Using Pattern Databases". Korf describes this method as follows IDA* is a depth-first search that looks for increasingly longer solutions in a series of iterations, using a lower-bound heuristic to prune branches once a lower bound on their length exceeds the current iterations bound. It works roughly as follows. First he identified a number of subproblems that are small enough to be solved optimally. He used: The cube restricted to only the corners, not looking at the edges The cube restricted to only 6 edges, not looking at the corners nor at the other edges. The cube restricted to the other 6 edges. Clearly the number of moves required to solve any of these subproblems is a lower bound for the number of moves needed to solve the entire cube. Given a random cube C, it is solved as iterative deepening. First all cubes are generated that are the result of applying 1 move to them. That is C * F, C * U, … Next, from this list, all cubes are generated that are the result of applying two moves. Then three moves and so on. If at any point a cube is found that needs too many moves based on the lower bounds to still be optimal it can be eliminated from the list. Although this algorithm will always find optimal solutions, there is no worst case analysis. It is not known in general how many iterations this algorithm will need to reach an optimal solution. An implementation of this algorithm can be found here. In 2006, Silviu Radu further improved his methods to prove that every position can be solved in at most 27 face turns or 35 quarter turns. Daniel Kunkle and Gene Cooperman in 2007 used a supercomputer to show that all unsolved cubes can be solved in no more than 26 moves (in face-turn metric). Instead of attempting to solve each of the billions of variations explicitly, the computer was programmed to bring the cube to one of 15,752 states, each of which could be solved within a few extra moves. All were proved solvable in 29 moves, with most solvable in 26. Those that could not initially be solved in 26 moves were then solved explicitly, and shown that they too could be solved in 26 moves. Tomas Rokicki reported in a 2008 computational proof that all unsolved cubes could be solved in 25 moves or fewer. This was later reduced to 23 moves. In August 2008, Rokicki announced that he had a proof for 22 moves. Finally, in 2010, Tomas Rokicki, Herbert Kociemba, Morley Davidson, and John Dethridge gave the final computer-assisted proof that all cube positions could be solved with a maximum of 20 face turns. In 2009, Tomas Rokicki proved that 29 moves in the quarter-turn metric is enough to solve any scrambled cube. And in 2014, Tomas Rokicki and Morley Davidson proved that the maximum number of quarter-turns needed to solve the cube is 26. The face-turn and quarter-turn metrics differ in the nature of their antipodes. An antipode is a scrambled cube that is maximally far from solved, one that requires the maximum number of moves to solve. In the half-turn metric with a maximum number of 20, there are hundreds of millions of such positions. In the quarter-turn metric, only a single position (and its two rotations) is known that requires the maximum of 26 moves. Despite significant effort, no additional quarter-turn distance-26 positions have been found.[needs update] Even at distance 25, only two positions (and their rotations) are known to exist.[citation needed] At distance 24, perhaps 150,000 positions exist. "World Cube Association". www.worldcubeassociation.org. Retrieved 2017-02-20. "God's Number is 20". cube20.org. Retrieved 2017-05-23. "God's Number is 26 in the Quarter Turn Metric". cube20.org. Retrieved 2017-02-20. Joyner, David (2002). Adventures in group theory: Rubik's Cube, Merlin's machine, and Other Mathematical Toys. Baltimore: Johns Hopkins University Press. pp. 7. ISBN 0-8018-6947-1. "Rubik's Cube Notation". Ruwix. Retrieved 2017-03-19. How to solve the 3x3x4 Cube How to solve a 4x4 Rubik's Cube Michael Reid's Rubik's Cube page M-symmetric positions Posted to Cube lovers on 2 Aug 1998 Rik van Grol (November 2010). "The Quest For God's Number". Math Horizons. Archived from the original on 2014-11-09. Retrieved 2013-07-26. Singmaster 1981, p. 16. Singmaster 1981, p. 26. Singmaster 1981, p. 30. Herbert Kociemba. "The Subgroup H and its cosets". Retrieved 2013-07-28. Progressive Improvements in Solving Algorithms Implementation of Thistlewaite's Algorithm for Rubik's Cube Solution in Javascript "Solve Rubik's Cube with Cube Explorer". kociemba.org. Retrieved 2018-11-27. Richard Korf (1997). "Finding Optimal Solutions to Rubik's Cube Using Pattern Databases" (PDF). Michael Reid's Optimal Solver for Rubik's Cube (requires a compiler such as gcc) Rubik can be solved in 27f Press Release on Proof that 26 Face Turns Suffice Kunkle, D.; Cooperman, C. (2007). "Twenty-Six Moves Suffice for Rubik's Cube" (PDF). Proceedings of the International Symposium on Symbolic and Algebraic Computation (ISSAC '07). ACM Press. Tom Rokicki (2008). "Twenty-Five Moves Suffice for Rubik's Cube". arXiv:0803.3435 [cs.SC]. Twenty-Three Moves Suffice — Domain of the Cube Forum twenty-two moves suffice Tom Rokicki. "Twenty-Nine QTM Moves Suffice". Retrieved 2010-02-19. Singmaster, David (1981). Notes on Rubik's Magic Cube. Enslow Publishers. Wikibooks has a book on the topic of: How to solve the Rubik's Cube How to solve the Rubik's Cube, a Wikibooks article that gives an overview over several algorithms that are simple enough to be memorizable by humans. However, such algorithms will usually not give an optimal solution which only uses the minimum possible number of moves.