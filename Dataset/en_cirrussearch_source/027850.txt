The Luhn algorithm or Luhn formula, also known as the "modulus 10" or "mod 10" algorithm, named after its creator, IBM scientist Hans Peter Luhn, is a simple check digit formula used to validate a variety of identification numbers. It is described in U.S. Patent No. 2,950,048, granted on August 23, 1960. The algorithm is in the public domain and is in wide use today. It is specified in ISO/IEC 7812-1. It is not intended to be a cryptographically secure hash function; it was designed to protect against accidental errors, not malicious attacks. Most credit cards and many government identification numbers use the algorithm as a simple method of distinguishing valid numbers from mistyped or otherwise incorrect numbers. The check digit is computed as follows: If the number already contains the check digit, drop that digit to form the "payload". The check digit is most often the last digit. With the payload, start from the rightmost digit. Moving left, double the value of every second digit (including the rightmost digit). Sum the values of the resulting digits. The check digit is calculated by (10−(smod10))mod10{\displaystyle (10-(s{\bmod {1}}0)){\bmod {1}}0}, where s is the sum from step 3. This is the smallest number (possibly zero) that must be added to s{\displaystyle s} to make a multiple of 10. Other valid formulas giving the same value are 9−((s+9)mod10){\displaystyle 9-((s+9){\bmod {1}}0)}, (10−s)mod10{\displaystyle (10-s){\bmod {1}}0}, and 10⌈s/10⌉−s{\displaystyle 10\lceil s/10\rceil -s}. Note that the formula (10−s)mod10{\displaystyle (10-s){\bmod {1}}0} will not work in all environments due to differences in how negative numbers are handled by the modulo operation. Assume an example of an account number 1789372997 (just the "payload", check digit not yet included): The sum of the resulting digits is 56. The check digit is equal to (10−(56mod⁡10))=4{\displaystyle (10-(56\operatorname {mod} 10))=4}. This makes the full account number read 17893729974. Drop the check digit (last digit) of the number to validate. (e.g. 17893729974 → 1789372997) Calculate the check digit (see above) Compare your result with the original check digit. If both numbers match, the result is valid. (e.g. (givenCheckDigit = calculatedCheckDigit) ⇔ (isValidCheckDigit)). The Luhn algorithm will detect all single-digit errors, as well as almost all transpositions of adjacent digits. It will not, however, detect transposition of the two-digit sequence 09 to 90 (or vice versa). It will detect most of the possible twin errors (it will not detect 22 ↔ 55, 33 ↔ 66 or 44 ↔ 77). Other, more complex check-digit algorithms (such as the Verhoeff algorithm and the Damm algorithm) can detect more transcription errors. The Luhn mod N algorithm is an extension that supports non-numerical strings. Because the algorithm operates on the digits in a right-to-left manner and zero digits affect the result only if they cause shift in position, zero-padding the beginning of a string of numbers does not affect the calculation. Therefore, systems that pad to a specific number of digits (by converting 1234 to 0001234 for instance) can perform Luhn validation before or after the padding and achieve the same result. The algorithm appeared in a United States Patent for a simple, hand-held, mechanical device for computing the checksum. The device took the mod 10 sum by mechanical means. The substitution digits, that is, the results of the double and reduce procedure, were not produced mechanically. Rather, the digits were marked in their permuted order on the body of the machine. The following function takes a card number, including the check digit, as an array of integers and outputs true if the check digit is correct, false otherwise. function isValid(cardNumber[1..length]) sum := 0 parity := length mod 2 for i from 1 to length do if i mod 2 != parity then sum := sum + cardNumber[i] elseif cardNumber[i] > 4 then sum := sum + 2 * cardNumber[i] - 9 else sum := sum + 2 * cardNumber[i] end if end for return cardNumber[length] == (10 - (sum mod 10)) end function bool IsValidLuhn(in int[1] digits) { int check_digit = 0; for (int i = digits.Length - 2; i >= 0; --i) check_digit += ((i & 1) is 0) switch { true => digits[i] > 4 ? digits[i] * 2 - 9 : digits[i] * 2, false => digits[i] }; return (10 - (check_digit % 10)) % 10 == digits.Last(); } public static boolean isValidLuhn(String number) { int checksum = Character.getNumericValue(number.charAt(number.length() - 1)); int total = 0; for (int i = number.length() - 2; i >= 0; i--) { int sum = 0; int digit = Character.getNumericValue(number.charAt(i)); if (i % 2 == number.length() % 2) { //right to left every odd digit digit = digit * 2; } sum = digit / 10 + digit % 10; total += sum; } return total % 10 != 0 ? 10 - total % 10 == checksum : checksum == 0; } The Luhn algorithm is used in a variety of systems, including: Credit card numbers IMEI numbers National Provider Identifier numbers in the United States Canadian social insurance numbers Israeli ID numbers South African ID numbers South African Tax reference numbers Swedish national identification numbers Swedish Corporate Identity Numbers (OrgNr) Greek Social Security Numbers (ΑΜΚΑ) ICCID of SIM cards European patent application numbers Survey codes appearing on McDonald's, Taco Bell, and Tractor Supply Co. receipts United States Postal Service package tracking numbers use a modified Luhn algorithm US patent 2950048A, Luhn, Hans P., "Computer for verifying numbers", published 1960-08-23  "Annex B: Luhn formula for computing modulus-10 "double-add-double" check digits". Identification cards — Identification of issuers — Part 1: Numbering system (Standard). International Organization for Standardization, International Electrotechnical Commission. January 2017. ISO/IEC 7812-1:2017. "Publication 199: Intelligent Mail Package Barcode (IMpb) Implementation Guide for Confirmation Services and Electronic Payment Systems". United States Postal Service. Retrieved 29 November 2023. Implementation in 150 languages on the Rosetta Code project