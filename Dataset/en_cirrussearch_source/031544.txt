A low-level programming language is a programming language that provides little or no abstraction from a computer's instruction set architecture—commands or functions in the language map that are structurally similar to processor's instructions. Generally, this refers to either machine code or assembly language. Because of the low (hence the word) abstraction between the language and machine language, low-level languages are sometimes described as being "close to the hardware". Programs written in low-level languages tend to be relatively non-portable, due to being optimized for a certain type of system architecture. Low-level languages can convert to machine code without a compiler or interpreter—second-generation programming languages use a simpler processor called an assembler—and the resulting code runs directly on the processor. A program written in a low-level language can be made to run very quickly, with a small memory footprint. An equivalent program in a high-level language can be less efficient and use more memory. Low-level languages are simple, but considered difficult to use, due to numerous technical details that the programmer must remember. By comparison, a high-level programming language isolates execution semantics of a computer architecture from the specification of the program, which simplifies development. Machine code is the only language a computer can process directly without a previous transformation. Currently, programmers almost never write programs directly in machine code, because it requires attention to numerous details that a high-level programming language handles automatically. Furthermore, unlike programming in an assembly language, it requires memorizing or looking up numerical codes for every instruction, and is extremely difficult to modify. True machine code is a stream of raw, usually binary, data. A programmer coding in "machine code" normally codes instructions and data in a more readable form such as decimal, octal, or hexadecimal which is translated to internal format by a program called a loader or toggled into the computer's memory from a front panel. Although few programs are written in machine languages, programmers often become adept at reading it through working with core dumps or debugging from the front panel. Example of a function in hexadecimal representation of x86-64 machine code to calculate the nth Fibonacci number, with each line corresponding to one instruction: 89 f8 85 ff 74 26 83 ff 02 76 1c 89 f9 ba 01 00 00 00 be 01 00 00 00 8d 04 16 83 f9 02 74 0d 89 d6 ff c9 89 c2 eb f0 b8 01 00 00 c3 Second-generation languages provide one abstraction level on top of the machine code. In the early days of coding on computers like TX-0 and PDP-1, the first thing MIT hackers did was to write assemblers. Assembly language has little semantics or formal specification, being only a mapping of human-readable symbols, including symbolic addresses, to opcodes, addresses, numeric constants, strings and so on. Typically, one machine instruction is represented as one line of assembly code. Assemblers produce object files that can link with other object files or be loaded on their own. Most assemblers provide macros to generate common sequences of instructions. Example: The same Fibonacci number calculator as above, but in x86-64 assembly language using AT&T syntax: fib: movl %edi, %eax ; put the argument into %eax testl %edi, %edi ; is it zero? je .return_from_fib ; yes - return 0, which is already in %eax cmpl $2, %edi ; is 2 greater than or equal to it? jbe .return_1_from_fib ; yes (i.e., it's 1 or 2) - return 1 movl %edi, %ecx ; no - put it in %ecx, for use as a counter movl $1, %edx ; the previous number in the sequence, which starts out as 1 movl $1, %esi ; the number before that, which also starts out as 1 .fib_loop: leal (%rsi,%rdx), %eax ; put the sum of the previous two numbers into %eax cmpl $2, %ecx ; is the counter 2? je .return_from_fib ; yes - %eax contains the result movl %edx, %esi ; make the previous number the number before the previous one decl %ecx ; decrement the counter movl %eax, %edx ; make the current number the previous number jmp .fib_loop ; keep going .return_1_from_fib: movl $1, %eax ; set the return value to 1 .return_from_fib: ret ; return In this code example, the registers of the x86-64 processor are named and manipulated directly. The function loads its 32-bit argument from %edi in accordance to the System V application binary interface for x86-64 and performs its calculation by manipulating values in the %eax, %ecx, %esi, and %edi registers until it has finished and returns. Note that in this assembly language, there is no concept of returning a value. The result having been stored in the %eax register, again in accordance with System V application binary interface, the ret instruction simply removes the top 64-bit element on the stack and causes the next instruction to be fetched from that location (that instruction is usually the instruction immediately after the one that called this function), with the result of the function being stored in %eax. x86-64 assembly language imposes no standard for passing values to a function or returning values from a function (and in fact, has no concept of a function); those are defined by an application binary interface, such as the System V ABI for a particular instruction set. Compare this with the same function in C: unsigned int fib(unsigned int n) { if (!n) return 0; else if (n <= 2) return 1; else { unsigned int f_nminus2, f_nminus1, f_n; for (f_nminus2 = f_nminus1 = 1, f_n = 0; ; --n) { f_n = f_nminus2 + f_nminus1; if (n <= 2) return f_n; f_nminus2 = f_nminus1; } } } This code is similar in structure to the assembly language example but there are significant differences in terms of abstraction: The input (parameter n) is an abstraction that does not specify any storage location on the hardware. In practice, the C compiler follows one of many possible calling conventions to determine a storage location for the input. The local variables f_nminus2, f_nminus2, and f_n are abstractions that do not specify any specific storage location on the hardware. The C compiler decides how to actually store them for the target architecture. The return function specifies the value to return, but does not dictate how it is returned. The C compiler for any specific architecture implements a standard mechanism for returning the value. Compilers for the x86 architecture typically (but not always) use the %eax register to return a value, as in the assembly language example (the author of the assembly language example has chosen to use the System V application binary interface for x86-64 convention but assembly language does not require this). These abstractions make the C code compilable without modification on any architecture for which a C compiler has been written. The x86 assembly language code is specific to the x86-64 architecture and the System V application binary interface for that architecture. During the late 1960s and 1970s, high-level languages that included some degree of access to low-level programming functions, such as PL/S, BLISS, BCPL, extended ALGOL and ESPOL (for Burroughs large systems), and C, were introduced. One method for this is inline assembly, in which assembly code is embedded in a high-level language that supports this feature. Some of these languages also allow architecture-dependent compiler optimization directives to adjust the way a compiler uses the target processor architecture. "3.1: Structure of low-level programs". Workforce LibreTexts. 2021-03-05. Retrieved 2023-04-03. Levy, Stephen (1994). Hackers: Heroes of the Computer Revolution. Penguin Books. p. 32. ISBN 0-14-100051-1.