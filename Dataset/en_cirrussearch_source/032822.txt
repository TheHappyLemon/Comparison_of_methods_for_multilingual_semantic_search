BogoMips (from "bogus" and MIPS) is a crude measurement of CPU speed made by the Linux kernel when it boots to calibrate an internal busy-loop. An often-quoted definition of the term is "the number of million times per second a processor can do absolutely nothing". BogoMips is a value that can be used to verify whether the processor in question is in the proper range of similar processors, i.e. BogoMips represents a processor's clock frequency as well as the potentially present CPU cache. It is not usable for performance comparisons among different CPUs. In 1993, Lars Wirzenius posted a Usenet message explaining the reasons for its introduction in the Linux kernel on comp.os.linux: [...] MIPS is short for Millions of Instructions Per Second. It is a measure for the computation speed of a processor. Like most such measures, it is more often abused than used properly (it is very difficult to justly compare MIPS for different kinds of computers). BogoMips are Linus's own invention. The linux kernel version 0.99.11 (dated 11 July 1993) needed a timing loop (the time is too short and/or needs to be too exact for a non-busy-loop method of waiting), which must be calibrated to the processor speed of the machine. Hence, the kernel measures at boot time how fast a certain kind of busy loop runs on a computer. "Bogo" comes from "bogus", i.e, something which is a fake. Hence, the BogoMips value gives some indication of the processor speed, but it is way too unscientific to be called anything but BogoMips. The reasons (there are two) it is printed during boot-up is that a) it is slightly useful for debugging and for checking that the computer[’]s caches and turbo button work, and b) Linus loves to chuckle when he sees confused people on the news. [...] As a very approximate guide, the BogoMips can be pre-calculated by the following table. The given rating is typical for that CPU with the then current and applicable Linux version. The index is the ratio of "BogoMips per clock speed" for any CPU to the same for an Intel 386DX CPU, for comparison purposes. With the 2.2.14 Linux kernel, a caching setting of the CPU state was moved from behind to before the BogoMips calculation. Although the BogoMips algorithm itself wasn't changed, from that kernel onward the BogoMips rating for then current Pentium CPUs was twice that of the rating before the change. The changed BogoMips outcome had no effect on real processor performance.[citation needed] In Linux, BogoMips can be easily obtained by searching the cpuinfo file: $ grep -i bogomips /proc/cpuinfo With kernel 2.6.x, BogoMips are implemented in the /usr/src/linux/init/calibrate.c kernel source file. It computes the Linux kernel timing parameter loops_per_jiffy (see jiffy) value. The explanation from source code: /* * A simple loop like * while ( jiffies < start_jiffies+1) * start = read_current_timer(); * will not do. As we don't really know whether jiffy switch * happened first or timer_value was read first. And some asynchronous * event can happen between these two events introducing errors in lpj. * * So, we do * 1. pre_start <- When we are sure that jiffy switch hasn't happened * 2. check jiffy switch * 3. start <- timer value before or after jiffy switch * 4. post_start <- When we are sure that jiffy switch has happened * * Note, we don't know anything about order of 2 and 3. * Now, by looking at post_start and pre_start difference, we can * check whether any asynchronous event happened or not */ loops_per_jiffy is used to implement udelay (delay in microseconds) and ndelay (delay in nanoseconds) functions. These functions are needed by some drivers to wait for hardware. Note that a busy waiting technique is used, so the kernel is effectively blocked when executing ndelay/udelay functions. For i386 architecture delay_loop is implemented in /usr/src/linux/arch/i386/lib/delay.c as: /* simple loop based delay: */ static void delay_loop(unsigned long loops) { int d0; __asm__ __volatile__( "\tjmp 1f\n" ".align 16\n" "1:\tjmp 2f\n" ".align 16\n" "2:\tdecl %0\n\tjns 2b" :"=&a" (d0) :"0" (loops)); } equivalent to the following assembler code ; input: eax = d0 ; output: eax = 0 jmp start .align 16 start: jmp body .align 16 body: decl eax jns body which can be rewritten to C-pseudocode static void delay_loop(long loops) { long d0 = loops; do { --d0; } while (d0 >= 0); } Full and complete information and details about BogoMips, and hundreds of reference entries can be found in the (outdated) BogoMips mini-Howto. In 2012, ARM contributed a new udelay implementation allowing the system timer built into many ARMv7 CPUs to be used instead of a busy-wait loop. This implementation was released in Version 3.6 of the Linux kernel. Timer-based delays are more robust on systems that use frequency scaling to dynamically adjust the processor's speed at runtime, as loops_per_jiffies values may not necessarily scale linearly. Also, since the timer frequency is known in advance, no calibration is needed at boot time. One side effect of this change is that the BogoMIPS value will reflect the timer frequency, not the CPU's core frequency. Typically the timer frequency is much lower than the processor's maximum frequency, and some users may be surprised to see an unusually low BogoMIPS value when comparing against systems that use traditional busy-wait loops. Turbo button Instructions per second Van Dorst, Wim (January 1996). "The Quintessential Linux Benchmark". Linux Journal. Retrieved 2008-08-22. Eric S Raymond, and Geoff Mackenzie, published on the Internet in the early 1990s, untraceable origin. Raymond, Eric S. "Hackers Jargon File". Van Dorst, Wim (2 March 2006). "BogoMips Mini-Howto" (V38 ed.). Retrieved 2008-08-22. Wirzenius, Lars. "Re: printing & BogoMips". Bekman, Stas. "What is a BogoMip?". "BogoMips mini-Howto". Deacon, Will. "ARM: 7452/1: delay: allow timer-based delay implementation to be selected". BogoMips Mini-Howto, V38 Sources of classical standalone benchmark