The SQL SELECT statement returns a result set of rows, from one or more tables. A SELECT statement retrieves zero or more rows from one or more database tables or database views. In most applications, SELECT is the most commonly used data manipulation language (DML) command. As SQL is a declarative programming language, SELECT queries specify a result set, but do not specify how to calculate it. The database translates the query into a "query plan" which may vary between executions, database versions and database software. This functionality is called the "query optimizer" as it is responsible for finding the best possible execution plan for the query, within applicable constraints. The SELECT statement has many optional clauses: SELECT list is the list of columns or SQL expressions to be returned by the query. This is approximately the relational algebra projection operation. AS optionally provides an alias for each column or expression in the SELECT list. This is the relational algebra rename operation. FROM specifies from which table to get the data. WHERE specifies which rows to retrieve. This is approximately the relational algebra selection operation. GROUP BY groups rows sharing a property so that an aggregate function can be applied to each group. HAVING selects among the groups defined by the GROUP BY clause. ORDER BY specifies how to order the returned rows. SELECT is the most common operation in SQL, called "the query". SELECT retrieves data from one or more tables, or expressions. Standard SELECT statements have no persistent effects on the database. Some non-standard implementations of SELECT can have persistent effects, such as the SELECT INTO syntax provided in some databases. Queries allow the user to describe desired data, leaving the database management system (DBMS) to carry out planning, optimizing, and performing the physical operations necessary to produce that result as it chooses. A query includes a list of columns to include in the final result, normally immediately following the SELECT keyword. An asterisk ("*") can be used to specify that the query should return all columns of all the queried tables. SELECT is the most complex statement in SQL, with optional keywords and clauses that include: The FROM clause, which indicates the table(s) to retrieve data from. The FROM clause can include optional JOIN subclauses to specify the rules for joining tables. The WHERE clause includes a comparison predicate, which restricts the rows returned by the query. The WHERE clause eliminates all rows from the result set where the comparison predicate does not evaluate to True. The GROUP BY clause projects rows having common values into a smaller set of rows. GROUP BY is often used in conjunction with SQL aggregation functions or to eliminate duplicate rows from a result set. The WHERE clause is applied before the GROUP BY clause. The HAVING clause includes a predicate used to filter rows resulting from the GROUP BY clause. Because it acts on the results of the GROUP BY clause, aggregation functions can be used in the HAVING clause predicate. The ORDER BY clause identifies which column[s] to use to sort the resulting data, and in which direction to sort them (ascending or descending). Without an ORDER BY clause, the order of rows returned by an SQL query is undefined. The DISTINCT keyword eliminates duplicate data. The following example of a SELECT query returns a list of expensive books. The query retrieves all rows from the Book table in which the price column contains a value greater than 100.00. The result is sorted in ascending order by title. The asterisk (*) in the select list indicates that all columns of the Book table should be included in the result set. SELECT * FROM Book WHERE price > 100.00 ORDER BY title; The example below demonstrates a query of multiple tables, grouping, and aggregation, by returning a list of books and the number of authors associated with each book. SELECT Book.title AS Title, count(*) AS Authors FROM Book JOIN Book_author ON Book.isbn = Book_author.isbn GROUP BY Book.title; Example output might resemble the following: Title Authors ---------------------- ------- SQL Examples and Guide 4 The Joy of SQL 1 An Introduction to SQL 2 Pitfalls of SQL 1 Under the precondition that isbn is the only common column name of the two tables and that a column named title only exists in the Book table, one could re-write the query above in the following form: SELECT title, count(*) AS Authors FROM Book NATURAL JOIN Book_author GROUP BY title; However, many[quantify] vendors either do not support this approach, or require certain column-naming conventions for natural joins to work effectively. SQL includes operators and functions for calculating values on stored values. SQL allows the use of expressions in the select list to project data, as in the following example, which returns a list of books that cost more than 100.00 with an additional sales_tax column containing a sales tax figure calculated at 6% of the price. SELECT isbn, title, price, price * 0.06 AS sales_tax FROM Book WHERE price > 100.00 ORDER BY title; Queries can be nested so that the results of one query can be used in another query via a relational operator or aggregation function. A nested query is also known as a subquery. While joins and other table operations provide computationally superior (i.e. faster) alternatives in many cases (all depending on implementation), the use of subqueries introduces a hierarchy in execution that can be useful or necessary. In the following example, the aggregation function AVG receives as input the result of a subquery: SELECT isbn, title, price FROM Book WHERE price < (SELECT AVG(price) FROM Book) ORDER BY title; A subquery can use values from the outer query, in which case it is known as a correlated subquery. Since 1999 the SQL standard allows WITH clauses, i.e. named subqueries often called common table expressions (named and designed after the IBM DB2 version 2 implementation; Oracle calls these subquery factoring). CTEs can also be recursive by referring to themselves; the resulting mechanism allows tree or graph traversals (when represented as relations), and more generally fixpoint computations. A derived table is a subquery in a FROM clause. Essentially, the derived table is a subquery that can be selected from or joined to. Derived table functionality allows the user to reference the subquery as a table. The derived table also is referred to as an inline view or a select in from list. In the following example, the SQL statement involves a join from the initial Books table to the derived table "Sales". This derived table captures associated book sales information using the ISBN to join to the Books table. As a result, the derived table provides the result set with additional columns (the number of items sold and the company that sold the books): SELECT b.isbn, b.title, b.price, sales.items_sold, sales.company_nm FROM Book b JOIN (SELECT SUM(Items_Sold) Items_Sold, Company_Nm, ISBN FROM Book_Sales GROUP BY Company_Nm, ISBN) sales ON sales.isbn = b.isbn Given a table T, the query SELECT * FROM T will result in all the elements of all the rows of the table being shown. With the same table, the query SELECT C1 FROM T will result in the elements from the column C1 of all the rows of the table being shown. This is similar to a projection in relational algebra, except that in the general case, the result may contain duplicate rows. This is also known as a Vertical Partition in some database terms, restricting query output to view only specified fields or columns. With the same table, the query SELECT * FROM T WHERE C1 = 1 will result in all the elements of all the rows where the value of column C1 is '1' being shown – in relational algebra terms, a selection will be performed, because of the WHERE clause. This is also known as a Horizontal Partition, restricting rows output by a query according to specified conditions. With more than one table, the result set will be every combination of rows. So if two tables are T1 and T2, SELECT * FROM T1, T2 will result in every combination of T1 rows with every T2 rows. E.g., if T1 has 3 rows and T2 has 5 rows, then 15 rows will result. Although not in standard, most DBMS allows using a select clause without a table by pretending that an imaginary table with one row is used. This is mainly used to perform calculations where a table is not needed. The SELECT clause specifies a list of properties (columns) by name, or the wildcard character (“*”) to mean “all properties”. Often it is convenient to indicate a maximum number of rows that are returned. This can be used for testing or to prevent consuming excessive resources if the query returns more information than expected. The approach to do this often varies per vendor. In ISO SQL:2003, result sets may be limited by using cursors, or by adding a SQL window function to the SELECT-statement ISO SQL:2008 introduced the FETCH FIRST clause. According to PostgreSQL v.9 documentation, an SQL window function "performs a calculation across a set of table rows that are somehow related to the current row", in a way similar to aggregate functions. The name recalls signal processing window functions. A window function call always contains an OVER clause. ROW_NUMBER() OVER may be used for a simple table on the returned rows, e.g. to return no more than ten rows: SELECT * FROM ( SELECT ROW_NUMBER() OVER (ORDER BY sort_key ASC) AS row_number, columns FROM tablename ) AS foo WHERE row_number <= 10 ROW_NUMBER can be non-deterministic: if sort_key is not unique, each time you run the query it is possible to get different row numbers assigned to any rows where sort_key is the same. When sort_key is unique, each row will always get a unique row number. The RANK() OVER window function acts like ROW_NUMBER, but may return more or less than n rows in case of tie conditions, e.g. to return the top-10 youngest persons: SELECT * FROM ( SELECT RANK() OVER (ORDER BY age ASC) AS ranking, person_id, person_name, age FROM person ) AS foo WHERE ranking <= 10 The above code could return more than ten rows, e.g. if there are two people of the same age, it could return eleven rows. Since ISO SQL:2008 results limits can be specified as in the following example using the FETCH FIRST clause. SELECT * FROM T FETCH FIRST 10 ROWS ONLY This clause currently is supported by CA DATACOM/DB 11, IBM DB2, SAP SQL Anywhere, PostgreSQL, EffiProz, H2, HSQLDB version 2.0, Oracle 12c and Mimer SQL. Microsoft SQL Server 2008 and higher supports FETCH FIRST, but it is considered part of the ORDER BY clause. The ORDER BY, OFFSET, and FETCH FIRST clauses are all required for this usage. SELECT * FROM T ORDER BY acolumn DESC OFFSET 0 ROWS FETCH FIRST 10 ROWS ONLY Some DBMSs offer non-standard syntax either instead of or in addition to SQL standard syntax. Below, variants of the simple limit query for different DBMSes are listed: Rows Pagination is an approach used to limit and display only a part of the total data of a query in the database. Instead of showing hundreds or thousands of rows at the same time, the server is requested only one page (a limited set of rows, per example only 10 rows), and the user starts navigating by requesting the next page, and then the next one, and so on. It is very useful, specially in web systems, where there is no dedicated connection between the client and the server, so the client does not have to wait to read and display all the rows of the server. {rows} = Number of rows in a page {page_number} = Number of the current page {begin_base_0} = Number of the row - 1 where the page starts = (page_number-1) * rows Select all rows from the database Read all rows but send to display only when the row_number of the rows read is between {begin_base_0 + 1} and {begin_base_0 + rows} Select * from {table} order by {unique_key} Select all the rows from the beginning of the table to the last row to display ({begin_base_0 + rows}) Read the {begin_base_0 + rows} rows but send to display only when the row_number of the rows read is greater than {begin_base_0} Select only {rows} rows starting from the next row to display ({begin_base_0 + 1}) Read and send to display all the rows read from the database Select only then {rows} rows with filter: First Page: select only the first {rows} rows, depending on the type of database Next Page: select only the first {rows} rows, depending on the type of database, where the {unique_key} is greater than {last_val} (the value of the {unique_key} of the last row in the current page) Previous Page: sort the data in the reverse order, select only the first {rows} rows, where the {unique_key} is less than {first_val} (the value of the {unique_key} of the first row in the current page), and sort the result in the correct order Read and send to display all the rows read from the database Some databases provide specialised syntax for hierarchical data. A window function in SQL:2003 is an aggregate function applied to a partition of the result set. For example, sum(population) OVER( PARTITION BY city ) calculates the sum of the populations of all rows having the same city value as the current row. Partitions are specified using the OVER clause which modifies the aggregate. Syntax: <OVER_CLAUSE> :: = OVER ( [ PARTITION BY <expr>, ... ] [ ORDER BY <expression> ] ) The OVER clause can partition and order the result set. Ordering is used for order-relative functions such as row_number. The processing of a SELECT statement according to ANSI SQL would be the following: select g.* from users u inner join groups g on g.Userid = u.Userid where u.LastName = 'Smith' and u.FirstName = 'John' the FROM clause is evaluated, a cross join or Cartesian product is produced for the first two tables in the FROM clause resulting in a virtual table as Vtable1 the ON clause is evaluated for vtable1; only records which meet the join condition g.Userid = u.Userid are inserted into Vtable2 If an outer join is specified, records which were dropped from vTable2 are added into VTable 3, for instance if the above query were: select u.* from users u left join groups g on g.Userid = u.Userid where u.LastName = 'Smith' and u.FirstName = 'John' all users who did not belong to any groups would be added back into Vtable3 the WHERE clause is evaluated, in this case only group information for user John Smith would be added to vTable4 the GROUP BY is evaluated; if the above query were: select g.GroupName, count(g.*) as NumberOfMembers from users u inner join groups g on g.Userid = u.Userid group by GroupName vTable5 would consist of members returned from vTable4 arranged by the grouping, in this case the GroupName the HAVING clause is evaluated for groups for which the HAVING clause is true and inserted into vTable6. For example: select g.GroupName, count(g.*) as NumberOfMembers from users u inner join groups g on g.Userid = u.Userid group by GroupName having count(g.*) > 5 the SELECT list is evaluated and returned as Vtable 7 the DISTINCT clause is evaluated; duplicate rows are removed and returned as Vtable 8 the ORDER BY clause is evaluated, ordering the rows and returning VCursor9. This is a cursor and not a table because ANSI defines a cursor as an ordered set of rows (not relational). The implementation of window function features by vendors of relational databases and SQL engines differs wildly. Most databases support at least some flavour of window functions. However, when we take a closer look it becomes clear that most vendors only implement a subset of the standard. Let's take the powerful RANGE clause as an example. Only Oracle, DB2, Spark/Hive, and Google Big Query fully implement this feature. More recently, vendors have added new extensions to the standard, e.g. array aggregation functions. These are particularly useful in the context of running SQL against a distributed file system (Hadoop, Spark, Google BigQuery) where we have weaker data co-locality guarantees than on a distributed relational database (MPP). Rather than evenly distributing the data across all nodes, SQL engines running queries against a distributed filesystem can achieve data co-locality guarantees by nesting data and thus avoiding potentially expensive joins involving heavy shuffling across the network. User-defined aggregate functions that can be used in window functions are another extremely powerful feature. Method to generate data based on the union all select 1 a, 1 b union all select 1, 2 union all select 1, 3 union all select 2, 1 union all select 5, 1 SQL Server 2008 supports the "row constructor" feature, specified in the SQL:1999 standard select * from (values (1, 1), (1, 2), (1, 3), (2, 1), (5, 1)) as x(a, b) Microsoft (23 May 2023). "Transact-SQL Syntax Conventions". MySQL. "SQL SELECT Syntax". Omitting FROM clause is not standard, but allowed by most major DBMSes. "Transact-SQL Reference". SQL Server Language Reference. SQL Server 2005 Books Online. Microsoft. 2007-09-15. Retrieved 2007-06-17. SAS 9.4 SQL Procedure User's Guide. SAS Institute (published 2013). 10 July 2013. p. 248. ISBN 9781612905686. Retrieved 2015-10-21. Although the UNIQUE argument is identical to DISTINCT, it is not an ANSI standard. Leon, Alexis; Leon, Mathews (1999). "Eliminating duplicates - SELECT using DISTINCT". SQL: A Complete Reference. New Delhi: Tata McGraw-Hill Education (published 2008). p. 143. ISBN 9780074637081. Retrieved 2015-10-21. [...] the keyword DISTINCT [...] eliminates the duplicates from the result set. PostgreSQL 9.1.24 Documentation - Chapter 3. Advanced Features OpenLink Software. "9.19.10. The TOP SELECT Option". docs.openlinksw.com. Retrieved 1 October 2019. Ing. Óscar Bonilla, MBA Inside Microsoft SQL Server 2005: T-SQL Querying by Itzik Ben-Gan, Lubor Kollar, and Dejan Sarka Horizontal & Vertical Partitioning, Microsoft SQL Server 2000 Books Online. Windowed Tables and Window function in SQL, Stefan Deßloch Oracle SELECT syntax Firebird SELECT syntax MySQL SELECT syntax PostgreSQL SELECT syntax SQLite SELECT syntax