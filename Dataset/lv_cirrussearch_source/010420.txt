Deikstras algoritms ir grafu meklēšanas algoritms, kurš risina viena izejas stāvokļa īsākā ceļa problēmu grafiem ar nenegatīviem šķautņu svariem, izveidojot īsākā ceļa koku. To 1956. gadā radīja un 1959. gadā publicēja nīderlandiešu datorzinātnieks Edsgers Deikstra. Šo algoritmu bieži izmanto maršrutēšanā un kā apakšprocedūru citiem grafu algoritmiem. Algoritms dotajai grafa virsotnei (mezglam) atrod ceļu ar viszemākajām izmaksām (t.i. īsāko ceļu) starp šo un katru citu virsotni. To var izmantot arī, lai atrastu izmaksas īsākajam ceļam no vienas virsotnes līdz citai virsotnei, apturot algoritmu, tiklīdz šis īsākais ceļš ir noteikts. Piemēram, ja grafa virsotnes attēlo pilsētas un šķautņu ceļa izmaksas attēlo nobraucamo attālumu starp pilsētām pa savienojošu ceļu, Deikstras algoritmu var izmantot, lai atrastu īsāko ceļu starp vienu pilsētu un visām citām parējām. Tā rezultātā īsākā ceļa atrašanu plaši izmanto tīkla maršrutēšanas protokolos, zināmākie no tiem IS-IS un OSPF (Open Shortest Path First). Deikstras sākotnējais algoritms neizmanto minimālo prioritāšu rindu un darbojas ar novērtējumu O(|V|2). Biežākā realizācija izmanto minimālo prioritāšu rindu, ko realizē ar Fibonači kaudzi un tā darbojas ar novērtējumu O(|E| + |V| log |V|). Tas ir asimptotiski ātrākais zināmais vienas izejas īsākā ceļa meklēšanas algoritms patvaļīgiem grafiem ar nenegatīviem šķautņu svariem. Par attālumu no mezgla Y sauksim attālumu no sākuma mezgla līdz Y. Deikstras algoritms piešķirs dažas sākotnējās attāluma vērības un mēģinās tās soli pa solim uzlabot. Piešķir katrai virsotnei iespējamo attāluma vērtību: sākuma virsotnei nulli, bet visām pārējām bezgalību. Atzīmē visas virsotnes, izņemot sākuma virsotni mezglu kā neapmeklētus. Uzstāda sākuma virsotni kā aktuālo. Izveido kopu ar neapmeklētajām virsotnēm, kura satur visas virsotnes, izņemot sākuma virsotni. Aktuālajai virsotnei apskata visus neapmeklētos kaimiņus un aprēķina to iespējamos attālumus. Piemēram, ja aktuālā virsotne A ir apzīmēta ar attālumu 6 un šķautne, kas to savieno ar kaimiņu B ir garumā 2, tad attālums līdz B (caur A) būs 6+2=8. Ja šis attālums ir mazāks kā iepriekš pierakstītais attālums, tad pārraksta šo attālumu. Lai arī kaimiņš ir apmeklēts, tas šobrīd netiek apzīmēts kā apmeklēts un paliek neapmeklēto kopā. Kad ir novērtēti visi aktuālās virsotnes kaimiņi, atzīmē aktuālo virsotni kā apmeklētu un izņem to no neapmeklēto kopas. Apmeklēta virsotne pēc tam vairs nekad netiks pārbaudīta; tās pierakstītais attālums ir galīgs un minimāls. Nākamā aktuālā virsotne būs virsotne, kura ir apzīmēta ar vismazāko (iespējamo) attālumu no neapmeklēto kopas. Ja neapmeklēto kopa ir tukša, apstājās. Algoritms ir beidzis darbību. Citā gadījumā uzstāda par aktuālo virsotni no neapmeklēto kopas ar vismazāko iespējamo attālumu un atgriežas pie 3. soļa. Dijkstra, Edsger; Thomas J. Misa, Editor (2010-08). "An Interview with Edsger W. Dijkstra". Communications of the ACM 53 (8): 41–47. doi:10.1145/1787234.1787249. "What is the shortest way to travel from Rotterdam to Groningen? It is the algorithm for the shortest path which I designed in about 20 minutes. One morning I was shopping with my young fianceé, and tired, we sat down on the café terrace to drink a cup of coffee and I was just thinking about whether I could do this, and I then designed the algorithm for the shortest path." Dijkstra 1959