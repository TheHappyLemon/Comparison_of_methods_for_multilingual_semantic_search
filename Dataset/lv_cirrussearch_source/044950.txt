Belmana—Forda algoritms ir algoritms īsākā ceļa meklēšanai starp doto un pārējām virsotnēm svērtos grafos. Atšķirībā no Deikstras algoritma Belmana—Forda algoritms pieļauj negatīvus šķautņu svarus, bet ir lēnāks, tāpēc parasti tiek izmantots, ja grafā ir šķautnes ar negatīviem svariem. Dots svērts grafs G = ( V , E ) {\displaystyle G=(V,E)} ar šķautņu svaru funkciju w {\displaystyle w} un sākuma virsotni s {\displaystyle s} . Izveidojams matricas A i j {\displaystyle A_{ij}} , kas saturēs īsāko ceļu no s {\displaystyle s} uz virsotni i {\displaystyle i} caur j {\displaystyle j} šķautnēm un P i j {\displaystyle P_{ij}} , kas satur iepriekšējo virsotni šādā ceļā. Matricā A {\displaystyle A} vienīgais ceļš no s {\displaystyle s} , kas satur 0 šķautnes ir tikai līdz pašai s {\displaystyle s} un tā garums ir 0. Tādējādi A s 0 = 0 {\displaystyle A_{s0}=0} . Visu pārējo ceļu sākotnējās vērtības ir + ∞ {\displaystyle +\infty } . Algoritms ir sekojošs: for v ∈ V {\displaystyle v\in V} for i ← 0 {\displaystyle i\gets 0} to | V | − 1 {\displaystyle |V|-1} do A v i ← + ∞ {\displaystyle A_{vi}\gets +\infty } A s 0 ← 0 {\displaystyle A_{s0}\gets 0} for i ← 1 {\displaystyle i\gets 1} to | V | − 1 {\displaystyle |V|-1} do for ( u , v ) ∈ E {\displaystyle (u,v)\in E} if A v i > A u , i − 1 + w ( u , v ) {\displaystyle A_{vi}>A_{u,i-1}+w(u,v)} then A v i ← A u , i − 1 + w ( u , v ) {\displaystyle A_{vi}\gets A_{u,i-1}+w(u,v)} P v i ← u {\displaystyle P_{vi}\gets u} Algoritma rezultātā matrica A i j {\displaystyle A_{ij}} satur īsākos ceļus no s {\displaystyle s} uz virsotni i {\displaystyle i} caur dažādiem šķautņu skaitiem j {\displaystyle j} . Pats īsākais ceļš starp s {\displaystyle s} un i {\displaystyle i} ir īsākais no tiem. Kad noskaidrots pats īsākais ceļš caur j {\displaystyle j} šķautnēm, pilnu ceļu masīvā p {\displaystyle p} var iegūt šādi: while j > 0 {\displaystyle j>0} p [ j ] ← i {\displaystyle p[j]\gets i} i ← P i j {\displaystyle i\gets P_{ij}} j ← j − 1 {\displaystyle j\gets j-1} return p Ja nepieciešams noskaidrot tikai īsākā ceļa garumu un nav nepieciešams zināt visu ceļu izmantojams šāds algoritms: for v ∈ V {\displaystyle v\in V} do d [ v ] ← + ∞ {\displaystyle d[v]\gets +\infty } d [ s ] ← 0 {\displaystyle d[s]\gets 0} for i ← 1 {\displaystyle i\gets 1} to | V | − 1 {\displaystyle |V|-1} do for ( u , v ) ∈ E {\displaystyle (u,v)\in E} d [ v ] ← min ( d [ v ] , d [ u ] + w ( u , v ) ) {\displaystyle d[v]\gets \min(d[v],d[u]+w(u,v))} return d {\displaystyle d} Šī algoritma rezultātā masīva d {\displaystyle d} elements d [ i ] {\displaystyle d[i]} saturēs īsākā ceļa garumu starp virsotnēm s {\displaystyle s} un i {\displaystyle i} . Belmana—Forda algoritma realizācija C /* Bellman-Ford Implementation */ #include <limits.h> #include <stdio.h> #include <stdlib.h> /* Let INFINITY be an integer value not likely to be confused with a real weight, even a negative one. */ #define INFINITY ((cin << 14)-1) typedef struct { int source; int dest; int weight; } Edge; void BellmanFord(Edge edges[], int edgecount, int nodecount, int source) { int *distance = (int*) malloc(nodecount * sizeof(*distance)); int i, j; for (i=0; i < nodecount; i++) distance[i] = INFINITY; /* The source node distance is set to zero. */ distance[source] = 0; for (i=0; i < nodecount; i++) { for (j=0; j < edgecount; j++) { if (distance[edges[j].source] != INFINITY) { int new_distance = distance[edges[j].source] + edges[j].weight; if (new_distance < distance[edges[j].dest]) distance[edges[j].dest] = new_distance; } } } for (i=0; i < edgecount; i++) { if (distance[edges[i].dest] > distance[edges[i].source] + edges[i].weight) { puts("Negative edge weight cycles detected!"); free(distance); return; } } for (i=0; i < nodecount; i++) { printf("The shortest distance between nodes %d and %d is %d\n", source, i, distance[i]); } free(distance); return; } int main(void) { /* This test case should produce the distances 2, 4, 7, -2, and 0. */ Edge edges[10] = {{0,1, 5}, {0,2, 8}, {0,3, -4}, {1,0, -2}, {2,1, -3}, {2,3, 9}, {3,1, 7}, {3,4, 2}, {4,0, 6}, {4,2, 7}}; BellmanFord(edges, 10, 5, 4); return 0; } Distance-vector maršrutēšanas protokoli, piemēram, RIP izmanto dalīto (distributed) Belmana—Forda algoritmu. Par dalīto to sauc tāpēc, ka tajā iesaistīti vairāki maršrutētāju vienā autonomajā sistēmā. Algoritma realizācija ir šāda: katrs mezgls aprēķina attālumus starp sevi un citiem mezgliem un saglabā rezultātus tabulā; tabula tiek izsūtīta citiem mezgliem; saņemot tabulu, mezgls aprēķina īsākos maršrutus starp sevi un citiem mezgliem un izdara izmaiņas tabulā. Interaktīva grafu teotijas algoritmu demonstrācija (Java)