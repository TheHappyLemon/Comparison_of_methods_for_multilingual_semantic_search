Datubāzes indekss ir datu struktūra, kas uzlabo datu ieguves ātrumu no datu bāzes tabulām, bet palēnina datu ierakstīšanu datu bāzes tabulās, kā arī šādas tabulas aizņem vairāk vietas. Indeksu var izveidot, izmantojot vienu vai vairākas datu bāzes tabulas kolonnas, kas paātrinās piekļuvi gan nejauši sakārtotiem datiem, gan arī sakārtotiem. Indeksi diskā parasti aizņem mazāk vietas, nekā dati, uz kuriem tie attiecas, kas dod iespēju uzglabāt indeksus atmiņā tabulām, kuru dati ir pārāk lieli, lai tās pašas uzglabātu atmiņā. Relāciju datu bāzēs, indekss ir kopija no daļas tabulas datu. Dažas datubāzes paplašina šo funkcionalitāti, ļaujot izveidot indeksus, kas balstās uz funkcijām vai izteiksmēm. Indeksu var definēt kā unikālu vai ne-unikālu. Unikālais indekss darbojas kā tabulas ierobežojums, neļaujot dublēt ierakstus indeksā un, līdz ar to, attiecīgajā tabulā. Indeksu arhitektūras var tikt klasificētas kā klasterotas un neklasterotas. Dati eksistē nejauši izvēlētā secībā, bet indekss norāda loģisko kārtību. Datu rindas var būt nejauši izkaisītas pa visu tabulu. Neklasterotā indeksa koks satur indeksa atslēgas sakārtotā veidā, kur lapas līmenis indeksa kokā satur norādi uz datu lapu un rindas numuru datu lapā. Neklasterotā indeksā Fiziskā rindu secība nav tāda pati kā indeksa rindu secība. Tipiski izveido uz kolonnām, kuras izmanto JOIN, WHERE, un ORDER BY norādījumos. Labi lietot tabulām, kuru dati bieži tiek mainīti. Microsoft SQL Server veido neklasterētus indeksus pēc noklusējuma, kad tiek izmantota komanda CREATE INDEX. Var eksistēt vairāk kā viens neklasterēts indekss datubāzes tabulā (līdz pat 249). Klasterošana izmaina datu blokus noteiktā secībā, lai tie atbilstu indeksam, tā nodrošinot, ka dati tiek glabāti jau sakārtoti. Tādēļ ir iespējams izveidot tikai vienu klasterotu indeksu katrai datubāzes tabulai. Klasterotie indeksi spēj ārkārtīgi palielināt datu nolasīšanas ātrumu, bet, parasti tikai tādos gadījumos, kur dati tiek lasīti secīgi vai arī pretējā secībā, kā tie norādīti klasterotajā indeksā. Tā kā fiziski dati ir sakārtoti jau uz diska, tas nozīmē, ka nākamais vai iepriekšējais ieraksts ir tieši aiz vai pirms konkrētā ieraksta un tādējādi tiek ietaupīts laiks, kas būtu jāpatērē, pāršķirot datu lapas. Indeksi ir lietderīgi daudzām lietotnēm, taču tie nāk ar ierobežojumiem. Apskatīsim šādu SQL priekšrakstu: SELECT first_name FROM people WHERE last_name = 'Smith';. Lai apstrādātu šādu priekšrakstu, bez indeksa, datu bāzes lietojumprogrammai ir jāvadās pēc last_name kolonnas, katrā rindā, kas atrodas galdā (kas ir pazīstama kā pilna galda nolasīšana). Savukārt ar indeksu datu bāze vienkārši sekos B-koka datu struktūrai līdz atradīs ierakstu "Smith". Šis process ir daudz ātrāks kā pilna galda nolasīšana. Apskatīsim šādu SQL priekšrakstu: SELECT email_address FROM customers WHERE email_address LIKE '%@yahoo.com';. Šis pieprasījums dotu e-pasta adresi katram klientam, kura e-pasta adrese beidzas ar "@yahoo.com", bet ja pat email_address kolonna ir tikusi indeksēta, datu bāzei tik un tā ir jāveic pilna galda nolasīšana. Tas ta ir tāpēc, ka indekss ir būvēts ar pieņēmumu, ka vārdi ir sakārtoti no kreisās puses uz labo. Ar aizstājējzīmi meklēšanas nosacījuma sākumā, datu bāzes lietujumprogramma nav spējīga izmantot pamata b-koka(b-tree) datu struktūru(citiem vārdiem sakot, WHERE noteikums nav ātrumu paaugstinošs, jo nevar izmantot indeksu priekšrocības, lai paātrinātu pieprasījumu izpildīšanu). Šī problēma var tikt atrisināta izmantojot citu indeksu pievienošanu, izmantojot reverse(email_adress) un SQL pieprasījumu šādi : SELECT email_address FROM customers WHERE reverse(email_address) LIKE reverse('%@yahoo.com');. Tas ieliek aizstājējzīmi pašā labajā pieprasījuma daļā (tagad t.i. moc.oohay@%), kas apmierina reverse(email_address) indeksu. Secība, kādā kolonnas ir sakārtotas indeksa definīcijā ir svarīga. Ir iespējams iegūt datu rindu identifikators izmantojot tikai pirmo indeksēto kolonnu, taču to nav iespējams efektīvi (lielākajā daļā datubāžu) izdarīt izmantojot otro vai vēl lielāku indeksēto kolonnu. Piemēram, iztēlojoties telefona grāmatu, kurā telefona numuri sakārtoti pēc pilsētas un pēc tam pēc uzvārda, zinot pilsētu, viegli atrast visus telefona numurus šajā pilsēta, bet, zinot uzvārdu, atrast visus telefona numurus ir samērā grūti. Bitmap indekss ir speciāls indeksa tips, kas glabā lielāko daļu tā datus kā bitu masīvus (bitmap) un uz lielāko daļu pieprasījumu datus atrod izpildot bitu loģiskās operācijas uz šiem masīviem. Visplašāk izmantotie indeksi, piemēram, B-Koks, ir visefektīvākie, ja vērtības šajos indeksos atkārtojas maz vai neatkārtojas vispār. Blīvais indekss datubāzēs ir datne, kurā glabājas atslēgu un norāžu pāri, kas norāda uz katru ierakstu datu datnē. Katra atslēga ir saistīta ar konkrētu norādi, kas norāda uz datu ierakstu. Klasterotajos indeksos ar atslēgam, kas atkārtojas, blīvais indekss norādīs uz pirmo ierakstu ar šādu atslēgu. Retais indekss datubāzēs ir datne, kurā glabājas atslēgu un norāžu pāri, kas norāda uz katru datu bloku datu datnē. Katra atslēģa ir saistīta ar konkrētu norādi, kas norāda uz datu bloku. Klasterotajos indeksos ar atslēgām, kas atkārtojas, retais indekss norādīs uz zemāko meklējamo atslēgu katra blokā. Apgrieztais indekss apgriež atslēgas vērtību, pirms to ievada indeksā. Piemēram, vērtība 123456 kļūst par 654321 indeksā. Vērtības apgriešana kļūst izteikti noderīga, kad tiek indeksēti secīgi dati (piemēram, skaitļu virkne) Indeksus var ieviest izmantojot dažādas datu struktūras. Populārakie indeksi ir sabalansētie koki, B-koki un jaucējfunkciju rezultāti. Using Clustered Indices, MSDN, retrieved 2010-08-27 Database Systems: The Complete Book. Hector Garcia-Molina, Jeffrey D. Ullman, Jennifer D. Widom Gavin Powell. «Chapter 12: Building Fast-Performing Data Models». Beginning Database Design ISBN 978-0-7645-7490-0. Wrox Publishing, 2005-12.