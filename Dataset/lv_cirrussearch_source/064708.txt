CPU laiks (vai procesa laiks) ir laiks, kurā centrālais procesors (CPU) tiek izmantots datorprogrammas vai operētājsistēmas instrukciju apstrādei pretstatā pagājušajam laikam, kas ietver, piemēram, ievades/izvades (Input/Output) darbību gaidīšanu vai pāreju uz mazjaudas (dīkstāves) režīmu. CPU laiks tiek mērīts sistēmas laikā vai sekundēs. Bieži vien ir lietderīgi izmērīt CPU laiku procentos no CPU jaudas, ko sauc par CPU lietojumu. CPU laikam un CPU lietojumam ir divi galvenie pielietojumi. CPU laiks tiek izmantots, lai kvantitatīvi noteiktu divu funkcionāli identisku algoritmu kopējo empīrisko efektivitāti. Piemēram, jebkurš datu šķirošanas algoritms ņem nešķirotu sarakstu un atgriež sakārtotu sarakstu, un to darīs deterministiskā soļu skaitā, pamatojoties uz doto ievades sarakstu. Tomēr burbuļkārtošanai un sapludināšanas kārtošanai ir atšķirīga darbības laika sarežģītība, tāpēc sapludināšanas kārtošana tiek paveikta mazāk soļos. Bez jebkādām zināšanām par abu algoritmu darbību, lielāks CPU laiks burbuļkārtošanai parāda, ka tas ir mazāk efektīvs konkrētiem ievades datiem par sapludināšanas kārtošanu. Šis mērījumu veids ir īpaši noderīgs, salīdzinot līdzīgus algoritmus, kuru sarežģītība nav triviāla. Šajā gadījumā reālajam laikam (faktiski pagājušajam laikam) nav nozīmes, dators var izpildīt programmu lēnāk vai ātrāk atkarībā no reālajiem mainīgajiem, piemēram, CPU temperatūras, kā arī citiem operētājsistēmas mainīgajiem, piemēram, procesa prioritātes. CPU lietojumu izmanto, lai kvantitatīvi noteiktu, kā procesors tiek koplietots starp datorprogrammām. Liels CPU lietojums vienai programmai var norādīt, ka tai ir ļoti nepieciešama apstrādes jauda vai tā var darboties nepareizi, piemēram, tā ir iekļuvusi bezgalīgā cilpā. CPU laiks ļauj izmērīt apstrādes jaudu, kas nepieciešama vienai programmai, novēršot traucējumus, piemēram, laiku, kas pavadīts, gaidot ievadi vai tiek apturēts, lai ļautu darboties citām programmām. Turpretim pagājušais reālais laiks (vai vienkārši reālais laiks vai sienas pulksteņa laiks) ir laiks, kas paiet no datorprogrammas sākuma līdz beigām, ko mēra ar parastu pulksteni. Pagājušajā reālajā laikā ir iekļauts ievades/izvades laiks, visas vairākuzdevumu aizkavēšanās un visi citi gaidīšanas veidi, kas rodas programmā. CPU laiku vai CPU lietojumu var ziņot vai nu katram pavedienam, katram procesam vai visai sistēmai. Turklāt atkarībā no tā, ko tieši CPU darīja, ziņotās vērtības var iedalīt: Lietotāja laiks ir laiks, cik ilgi centrālais procesors bija aizņemts, izpildot kodu lietotāja telpā. Sistēmas laiks ir laiks, cik ilgi centrālais procesors bija aizņemts, izpildot kodu kodola telpā. Ja šī vērtība ir norādīta pavedienam vai procesam, tā norāda laiku, cik ilgi kodols veica darbu izpildes konteksta vārdā, piemēram, pēc pavediena sistēmas izsaukuma. Dīkstāves laiks (tikai visai sistēmai) ir laiks, kurā centrālais procesors nebija aizņemts, vai, pretējā gadījumā, laiks, cik ilgi tas izpildīja sistēmas dīkstāves procesu. Dīkstāves laiks faktiski mēra neizmantoto CPU jaudu. Nozagšanas laiks (tikai visai sistēmai) virtualizētajā aparatūrā ir laiks, cik ilgi operētājsistēma bija paredzējusi izpildei, bet to neļāva hipervizors. Tas var notikt, ja fiziskajā aparatūrā darbojas vairākas viesu operētājsistēmas un hipervizors izvēlējās piešķirt CPU laika slotu citai. Unix komandu procesu tabula (top) nodrošina CPU laiku, prioritāti, pagājušo reālo laiku un citu informāciju par visiem procesiem un atjaunina to reālajā laikā. Unix komandas laiks drukā Unix procesa CPU laiku un pagājušo reālo laiku. % gcc nextPrimeNumber.c -o nextPrimeNumber % time ./nextPrimeNumber 30000007 Prime number greater than 30000007 is 30000023 0.327u 0.010s 0:01.15 28.6% 0+0k 0+0io 0pf+0w Šis process kopumā aizņēma 0,337 sekundes CPU laika, no kurām 0,327 sekundes tika pavadītas lietotāja telpā un pēdējās 0,010 sekundes kodola režīmā procesa vārdā. Pagājušais reālais laiks bija 1,15 sekundes. Zemāk ir norādīts iepriekš minētajā piemērā izmantotās lietojumprogrammas nextPrimeNumber pirmkods. // nextPrimeNumber.c #include <stdio.h> #include <stdlib.h> int isPrimeNumber(unsigned long int n) { for (int i = 2; i <= (n >> 1); ++i) if (n % i == 0) return 0; return 1; } int main(int argc, char *argv[]) { unsigned long int argument = strtoul(argv[1], NULL, 10), n = argument; while (!isPrimeNumber(++n)); printf("Prime number greater than %lu is %lu\n", argument, n); return 0; } POSIX funkcijas clock() un getrusage() var izmantot, lai iegūtu CPU laiku, ko patērē jebkurš process POSIX vidē. Ja process ir daudzpavedienu, CPU laiks ir visu pavedienu summa. Linux, sākot no kodola 2.6.26, ir parametrs RUSAGE_THREAD, kas ved uz resursu izmantošanas statistiku tikai izsaucošajam pavedienam. Vairāku procesoru iekārtās datorprogramma apstrādei var izmantot divus vai vairākus CPU, izmantojot paralēlās apstrādes plānošanu. Šādās situācijās tiek izmantots kopējā CPU laika jēdziens, kas ir CPU laika summa, ko patērē visi datorprogrammas izmantotie CPU. Pagājušais reālais laiks vienmēr ir lielāks vai vienāds ar CPU laiku datorprogrammām, kuras apstrādei izmanto tikai vienu CPU. Ja Ievade/Izvade vai citi resursi nav jāgaida, pagājušais reālais laiks un CPU laiks ir ļoti līdzīgi. Ja programma izmanto paralēlo apstrādi, kopējais CPU laiks šai programmai būtu lielāks nekā tās pagājušais reālais laiks. Kopējais CPU laiks/CPU skaits būtu tāds pats kā pagājušajā reālajā laikā, ja darba slodze ir vienmērīgi sadalīta katram CPU un nav jāgaida Ievade/Izvade vai citi resursi. Piemērs: lietojumprogramma, kas tiek izpildīta uz seškodolu procesora, izveido trīs Unix procesus, lai izpildītu lietotāja prasības. Katrs no šiem trim procesiem veido divus pavedienus, kopā uzskaitot 6 darba pavedienus. Aprēķini ir vienmērīgi sadalīti pa 6 neatkarīgiem pavedieniem. Ja nav jāgaida resursi, paredzams, ka kopējais CPU laiks sešas reizes pārsniedz pagājušo reālo laiku. Christian Ehrhardt. «CPU time accounting». IBM, July 2010. Skatīts: 2014-08-05. Chandra Thimmannagari. CPU Design: Answers to Frequently Asked Questions. Springer, 2005-01-01. 68. lpp. ISBN 0-387-23799-2. «Processor And CPU Time». The GNU C Library. 2014-02-09. Skatīts: 2014-08-05. «clock - report CPU time used». The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition. Skatīts: 2014-08-05. «getrusage - get information about resource utilization». The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition. Skatīts: 2014-08-05.