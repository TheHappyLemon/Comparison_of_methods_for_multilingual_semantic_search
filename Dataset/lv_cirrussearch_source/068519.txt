OpenGL (Open Graphics Library — 'atklātā grafiskā bibliotēka') — specifikācija, kas nosaka no programmēšanas valodas neatkarīgu vairākplatformu lietojumprogrammu saskarni, kas izmanto divdimensiju un trīsdimensiju grafiku. OpenGL sevī iekļauj vairāk kā 250 sarežģītu trīsdimensiju ainavu zīmēšanai no vienkāršiem primitīviem paredzētas funkcijas. OpenGL izstrādāja Silicon Graphics Inc. (SGI) 1992. gadā un tas tiek plaši izmantots datorspēļu izveidē, datorizētā projektēšanā, virtuālajā realitātē, zinātniskajā un informācijas vizualizēšanā, un lidojumu simulācijā. OpenGL aktīvi konkurē ar Direct3d Windows vidē. Pašos pamatos, OpenGL — tā ir tikai specifikācija, proti, dokuments, kas apraksta funkciju kopumu un to darbību precīzu aprakstu, ko šīm funkcijām ir jāveic. Aparatūras ražotāji uz šīs specifikācijas pamata rada "realizācijas" — funkciju bibliotēkas, kas atbilst specifikācijas funkciju kopumam. Realizācija izmanto aparatūras iespējas, kur vien tas ir pieejams. Ja aparatūra neatbalsta to vai citu iespēju, tad šī iespēja tiek emulēta programmas līmenī. Ražotāju aparatūrai, pirms tās izziņošanas par OpenGL saderīgu, ir nepieciešams iziet specifiskus standartsaderības testus. Efektīva OpenGL realizācija ir gan Windows, MacOS, Linux un Unix platformās, PlayStation 3 un pat TI-89 grafiskajā platformā. Pastāv daudzi OpenGL funkciju īstenojumi, kas ļauj OpenGL darboties uz dažādām platformām, uz kurām pārdevējs nav paredzējis šādu atbalstu. Zīmīgi, ka brīvās programmatūras/atklātā pirmkoda bibliotēka Mesa 3D ir OpenGL funkciju programmrealizācija. Pateicoties licences specifikai, Mesa ir "neoficiāla" OpenGL realizācija, kaut arī tā koda līmenī ir pilnībā ir savietojama ar OpenGL. OpenGL specifikāciju uzrada OpenGL Architecture Review Board (ARB), kuru šī mērķa īstenošanai nodibināja 1992. gadā. Konsorciju veido kompānijas, kas ir ieinteresētas plaši izplatītas un izmantojamas lietojumprogrammatūras saskarnes radīšanā. Atbilstoši OpenGL mājaslapā sniegtajai informācijai, 2004. gadā ARB biedru ar izšķirošām balsstiesībām vidū bija: profesionālās grafiskās aparatūras ražotāji SGI, 3Dlabs, Matrox un Evans & Sutherland (militārā aparatūra), plaša patēriņa grafiskās aparatūras ražotāji ATI un NVIDIA, procesoru ražotājs Intel, kā arī datoru un datoraparatūras ražotāji IBM, Apple, Dell, Hewlett-Packard un Sun Microsystems. Tāpat ARB biedru ar izšķirošām balsstiesībām ir arī viens no datorspēļu industrijas līderiem id Software. Microsoft, kas bija viens no konsorcija dibinātājiem, 2003. gadā izstājās no ARB. Pateicoties politikai — ik gadu aicināt daudzas kompānijas viena gada garumā ņemt līdzdalību OpenGL ARB darbībā — ir ļāvis OpenGL kļūt par plaša pielietojuma lietojumprogrammatūras saskarni ar plašām iespējām. 2006. gada 21. septembrī OpenGL uzraudzība tika nodota Khronos Group.[3] Tas tika darīts ar mērķi optimizēt OpenGL mārketingu un novērst šķēršļus, ko bija radījuši OpenGL un OpenGL ES dažādā attīstība. Khronos apakšstruktūra, ka vada OpenGL, vēsturisku iemeslu dēļ tika nosaukta OpenGL ARB Working Group. Kurts Ekelejs (Kurt Akeley) un Marks Sīgals (Mark Segal) ir OpenGL sākotnējās specifikācijas autori. Kriss Freizers (Chris Frazier) ir 1.1 versijas redaktors. Jons Ličs ir bijis redaktors visām turpmākajām OpenGL versijām, sākot no 1.2 līdz 2.1. OpenGL ir orientēts divu uzdevumu veikšanai: novērst grūtības, kas ir saistītas ar dažādu 3D paātrinātāju darbību, izstrādātājiem piedāvājot vienu lietojumprogrammas saskarni; novērst aparatūras platformu iespēju atšķirības, pieprasot, lai visas implementācijas atbalstīt pilnu OpenGL iespēju kopumu (lietojot programmas emulāciju, ja tas nepieciešams). OpenGL pamatuzdevums ir pieņemt primitīvus kā punktus, līnijas un poligonus, un konvertēt tos pikseļos. To paveic grafiskais konveijers (graphics pipeline), ko pazīst arī kā known as the OpenGL state machine Arhivēts 2008. gada 16. maijā, Wayback Machine vietnē.. Lielākā daļa OpenGL komandu ir saistītas vai nu ar primitīvu nodošanu grafiskajam konveijeram vai arī veidu, kā konveijers apstrādā šos primitīvus. Pirms OpenGL 2.0 versijas, konveijerapstrādes katrs posms tika izpildīts kā katras ainas fiksēta funkcija(fixed function) un bija konfigurējams tikai šauros limitos. OpenGL 2.0 piedāvā vairākus posmus, kas ir pilnībā programmējami izmantojot GLSL. OpenGL ir zema līmeņa, procedūru lietojumprogrammas saskarne, kas no programmētāja pieprasa secīgu soļu izpildi, lai renderētu ainu. Tā ir pamatatšķirība, kas OpenGL atšķir no deskriptīvās pieejas (descriptive API, scene graph vai retained mode), kad visa aina tiek nodota datu kopuma (visbiežāk visa koka) formā, kas pēc tam tiek apstrādāta un atainota uz ekrāna. No vienas puses imperatīvā pieeja no programmētāja prasa dziļas trīsdimensiju grafikas un matemātisko modeļu zināšanas, bet no otras — dod iespēju integrēt dažādas inovācijas, piemēram, renderēšanas algoritmus. Vēsturiski OpenGL ir ietekmējis 3D grafikas paātrinātāju attīstību, piegādājot funkcionalitātes bāzes līmeni, kas tagad ir pašsaprotams plaša patēriņa aparatūrā: Rastras punkti, līnijas un poligoni kā vienkārši primitīvi, Transformāciju un gaismojuma konveijers (transform and lighting pipeline) Z-buferizācija (Z-buffering) Faktūrkartēšana (texture mapping) Alfa pārēju nodrošinājums (alpha blending) Īss grafiskajā konveijerā notiekošo procesu apraksts varētu būt šāds: Ja nepieciešams, to polinomiālo funkciju, kas definē noteiktas ievades, piem., splainu (Nonuniform rational B-spline, NURBS) virsmas, aptuvenu līkņu un virsmu ģeometrijas analīze(evaluation). Virsotņu (vertex) operācijas, to pārveide un gaismošana, izejot no to materiāla. Ainas neredzamo daļu "apcirpšana" ar mērķi parādīt skatāmu vienību. Rastrēšana (Rasterisation) vai iepriekšējās informācijas pārvēršana pikseļos. Daudzstūri tiek attēloti kā atbilstošas krāsas ar interpolācijas algoritmu palīdzību. Fragmentsoļu operācijas (per-fragment operations) kā, piem., vērtību atjaunināšana atkarībā no ienākošajām un iepriekš noglabātajām dziļuma vērtībām (depth value) vai arī atkarībā no krāsu kombinācijām. Un fragmenti tiek ievietoti kadru buferī (frame buffer). Daudzi mūsdienīgi 3D grafikas paātrinātāji piedāvā daudz plašāku funkcionalitāti par augstākminēto, bet šīs jaunās iespējas lielākoties ir pamatkonveijera uzlabojumi, nevis radikāli pārveidojumi. Šis piemērs demonstrē, kā uz ekrāna uzzīmēt zaļu laukumu. OpenGL ir vairākas metodes šī uzdevuma veikšanai, un šī ir vissaprotamākā. glClear( GL_COLOR_BUFFER_BIT ); Šis priekšraksts attīra krāsu buferi, lai ekrāns būtu tīrs. glMatrixMode( GL_PROJECTION ); /* Subsequent matrix commands will affect the projection matrix */ glLoadIdentity(); /* Initialise the projection matrix to identity */ glFrustum( -1, 1, -1, 1, 1, 1000 ); /* Apply a perspective-projection matrix */ Šie priekšraksti uzsāk matrices projicēšanu, uzstādot 3D šķeltā konusa (frustum) matrici, kas veido redzamo laukumu. Šī matrice pārveido kamerrelatīvās telpas (camera-relative space) objektus OpenGL projekciju telpas objektos. glMatrixMode( GL_MODELVIEW ); /* Subsequent matrix commands will affect the modelview matrix */ glLoadIdentity(); /* Initialise the modelview to identity */ glTranslatef( 0, 0, -3 ); /* Translate the modelview 3 units along the Z axis */ Šie priekšraksti iniciē modeļskata matrici(modelview matrix). Šī matrice nosaka transformāciju no modeļrelatīvajām koordinātēm uz kameras telpu. Modeļskata un projekcijas matrices apvienojums objektus transformē no modeļrelatīvās telpas uz projekcijas ekrāna telpu. glBegin( GL_POLYGON ); /* Begin issuing a polygon */ glColor3f( 0, 1, 0 ); /* Set the current color to green */ glVertex3f( -1, -1, 0 ); /* Issue a vertex */ glVertex3f( -1, 1, 0 ); /* Issue a vertex */ glVertex3f( 1, 1, 0 ); /* Issue a vertex */ glVertex3f( 1, -1, 0 ); /* Issue a vertex */ glEnd(); /* Finish issuing the polygon */ Šīs komandas uzzīmē zaļu laukumu XY plaknē (plane). OpenGL popularitātes pamatā daļēji ir lieliskā tai pieejamā dokumentācija. OpenGL ARB ir izlaidusi vairākas rokasgrāmatas līdztekus specifikāciju dokumentiem, kas tiek aktīvi atjaunināti no versijas uz versiju un apraksta visus jauninājumus un iespējas, kas ir pieejamas lietojumprogrammas saskarnēs. Šīs grāmatas ir hrestomātiski darbi par OpenGL: The Red Book — OpenGL Programming Guide, 5th edition. [1] Lasāma rokasgrāmata / Atsauču grāmata — "obligāta" grāmata OpenGL programmētājiem. Pirmais izdevums elektroniski pieejams tiešsaistē te un te. The Blue Book — OpenGL Reference manual, 4th edition. Būtībā cietvāku izdevums ar Unix rokasgrāmatas lappusēm (Unix manual pages) par OpenGL. Grāmatā atradīsiet plakāta izmēra diagrammu, kas demonstrē idealizētu OpenGL implementāciju. Grāmata ir pieejama šeit. The Green Book — OpenGL Programming for the X Window System. Grāmata par X11 saskarņošanu (interfacing) un OpenGL Utility Toolkit (GLUT). The Alpha Book (kurai gan, patiesību sakot, ir balts vāks) — OpenGL Programming for Windows 95 and Windows NT. Grāmata par OpenGL saskarņošanu Microsoft Windows vidē. Par OpenGL 2.0 un turpmākajām versijām: The Orange Book — The OpenGL Shading Language. Rokasgrāmata un atsauču kolekcija par GLSL. OpenGL standarti ļauj individuāliem pārdevējiem (vendors) nodrošināt papildusfunkcionalitāti ar paplašinājumu (extensions) palīdz;ibu, kolīdz ir radīta jauna tehnoloģija. Ar paplašinājumu palīdzību var ieviest jaunas funkcijas un konstantes, kā arī atvieglot vai noņemt ierobežojumus esošās OpenGL funkcijās. Katrs pārdevējs lieto alfabētisku saīsinājumu, kas tiek izmantots pārdevēja jauno funkciju un konstanšu apzīmēšanai. Piemēram, saīsinājums (NV) tiek lietots NVIDIA patentēto funkciju glCombinerParameterfvNV() un konstanšu GL_NORMAL_MAP_NV apzīmēšanai. Pastāv iespēja, ka kāds cits pārdevējs piekrīt implementēt otra pārdevēja paplašināto funkcionalitāti. Tādā gadījumā šādas funkcionalitātes apzīmēšanai tiek lietots saīsinājums EXT. Pēcāk pastāv iespēja, ka Architecture Review Board (ARB), OpenGL konsorcijs, "svēta" šo paplašinājumu. Tādā gadījumā tas vēlāk kļūst par standarta paplašinājumu, un tā apzīmēšanai tiek lietos saīsinājums ARB. Pats pirmais ARB paplašinājums bija GL_ARB_multitexture, ko ieviesa OpenGL 1.2.1. versijā. Savukārt faktūrkartēšana(multitexturing), atbilstoši oficiālajai paplašinājumu veicināšanas politikai, tika nevis implementēta kā brīvizvēles ARB paplašinājums, bet gan iekļauta kā OpenGL lietojumprogrammas kodola saskarnē, sākot ar 1.3 versiju. Lai paplašinājumu varētu izmantot, programmai no sākuma vajag noteikt tā pieejamību un darbgatavību, un tad iegūt norādes (pointers) uz jaunajām funkcijām, kuras sniedz paplašinājums. Šīs darbības mehānisms ir katrai platformai atšķirīgs un tādas bibliotēkas kā GLEW un GLEE visupirms ir radītas šī procesa vienkāršošanai. Teju vai visu paplašinājumu specifikācijas var aplūkot oficiālajā paplašinājumu reģistrā [2]. Atsevišķas bibliotēkas ir "iebūvētas" OpenGL bāzē vai ārpus tās, lai nodrošinātu iespējas, kas pašā OpenGL nav pieejams. Tādas bibliotēkas kā GLU var atrast OpenGL implementācijās, kamēr citas kā, piemēram, GLUT un SDL ir attīstījušas laika gaitā un nodrošinājušas rudimentāru vairākplatformu logošanas (windowing) un peles funkcionalitāti, un, ja tā nav bijusi pieejama, tad šīs bibliotēkas bija ērti lejupielādējamas un pievienojamas izstrādes videi. Vienkāršas grafiskā lietotāja saskarnes (GUI) funkcionalitāte ir pieejama tādās bibliotēkās kā GLUI vai FLTK. Citas bibliotēkas kā, piemēram, AUX ir "atmestas" (deprecated) un aizstātas ar funkcionalitāti, kas ir plaši pieejama daudz populārākās bibliotēkās, tomēr AUX kods, ko tās lieto, aizvien ir pieejams vienkāršās pamācībās. Vēl citas bibliotēkas ir radītas, lai nodrošinātu OpenGL programmu izstrādātājus ar vienkāršiem OpenGL paplašinājumu un versiju pārvaldības līdzekļiem. Pie šādām bibliotēkām pieskaitāmas GLEW (the OpenGL Extension Wrangler Library) un GLEE (the OpenGL Easy Extension Library). Līdztekus iepriekšminētajām vienkāršajām bibliotēkām, ir arī augstākā līmeņa objektorientētu ainu grafu paturošā režīma (retained mode) bibliotēkas, un tās būtu PLIB, OpenSG, OpenSceneGraph un OpenGL Performer bibliotēkas. Tās ir pieejamas kā vairākplatformu atklātā pirmkoda programmatūras vai kā īpašniekprogrammatūras saskarnes, kas ir iekļautas OpenGL bāzē vai sistēmas bibliotēkās un ir paredzētas reāllaika skaitļošanas iespējošanai vizuālās simulācijas lietotņu darbā. Citi risinājumi atbalsta OpenGL virtuālā realitātes programmu, mērogojamības un grafisko klastera pielietojamības paralēldarbību, kā piemēram, caurspīdīgi kā Chromium vai caur programmas saskarni — Equalizer gadījumā. Mesa 3D ir atklātā pirmkoda OpenGL implementācija. Mesa 3D nodrošina OpenGL programmatūras līmeņa renderēšanu, kā arī aparatūras paātrināšanu Linux sistēmā vairākām 3D videokartēm. Sākot ar 2007. gada 22. jūniju Mesa 3D īsteno 2.1 versiju un izplata atsevišķus savus paplašinājumus dažādām platformām. Lai izceltu OpenGL dažādu programmēšanas valodu un vairākplatformu raksturu, dažādas piesaistes un porti ir izveidoti priekš OpenGL daudzās programmēšanas valodās. Dažas no šīm valodām un piesaistēm ir: Ada: Ada OpenGL 1.1 atbalsta GL, GLU and GLUT [3] BlitzMax: OOP valoda bez izpildlaika (runtime). Atbalsta Win32/64, Linux, OSX(PPC,intel). Iebūvēts OpenGL atbalsts. C#: Tao ietvars(framework) priekš Microsoft .NET, iekļauto multivides bibliotēku starpā ir arī OpenGL [4] D: Vairāk informācijas bindings un Project Derelict Delphi: Dot[5] Fortran: f90gl atbalsta OpenGL 1.2, GLU 1.2 un GLUT 3.7 [6] FreeBASIC: Vietējais OpenGL atbalsts. Iebūvēta OpenGL konteksta radīšana. Haskell: HOpenGL atbalsta GL, GLU un GLUT. Komplektā iekļauta arī Glasgow Haskell Compiler pēdējā versija. [7] Java: Java Bindings for OpenGL (JSR 231) un Java OpenGL (JOGL) Lightweight Java Game Library (LWJGL) Lisp: Vairāk informācijas: the cl-opengl project at common-lisp.net Scheme: Chicken Egg,OpenGL bindings for PLT Scheme, OpenGL bindings for Gauche Scheme Mercury Prolog mtogl Ocaml: GLCaml un LablGL Perl: Perl OpenGL (POGL) modulis — C valodā rakstītas koplietojamās bibliotēkas C vs Perl and Perl vs Python veiktspējas testi Pike: Vietējā OpenGL saskarne. Tāpat tiek atbalstīts arī GLU un GLUT [8] PHP: See http://phpopengl.sourceforge.net/ Arhivēts 2008. gada 21. martā, Wayback Machine vietnē. PureBasic: Vietējais OpenGL atbalsts. Python: PyOpenGL atbalsta GL, GLU un GLUT [9] Ruby: Vairāk informācijas [10] — atbalsta GL, GLU un GLUT Smalltalk, kā tas bija redzams, Croquet Project darbojas uz Squeak Smalltalk Visual Basic: ActiveX Control Visual Prolog komerciāla redakcija Vairāk par OpenGL piesaistēm: opengl.org viki. OpenGL ir veidots, lai nodrošinātu grafikas izvadi: tas nodrošina tikai renderēšanas funkcijas. Lietojumprogrammas saskarnes kodolā nav logošanas sistēmas, audio, izdrukas uz ekrāna, tastatūras, peles vai kādas citas ievadierīces koncepta. Neskatoties uz to, ka pirmajā brīdī tas varētu šķist ierobežojoši, tieši tas pieļauj tādu kodu, kas padara iespējamu renderēšanu neatkarīgi no izmantotās operētājsistēmas, izstrādi tādējādi pārvēršot par vairākplatformu. Un tomēr — ierobežotu apmēru integrācija vietējā logošanas sistēmā ir nepieciešama, lai neapgrūtināta mijiedarbība ar saimniekdatoru būtu iespējama. Tas tiek panākts, izmantojot sekojošos lietojumprogrammas saskarnes papildinājumus: GLX — X11 (ieskaitot tīkla caurspīdību) WGL — Microsoft Windows CGL — Mac OS X. Labāka integrācija ar Mac OS X programmu darbvidi tiek nodrošināta ar CGL slāņotu (layered) lietojumprogrammas saskarņu palīdzību: AGL priekš Carbon un NSOpenGL priekš Cocoa. Jāmin arī GLUT, SDL un GLFW bibliotēkas, kas nodrošina pārnesamu (portable) vienkāršas logošanas funkcionalitāti. 1980. gados tādas programmatūras izstrādes, kas spētu mijiedarboties ar plaša diapazonu grafisko aparatūru, bija īsts izaicinājums. Programmatūras izstrādātāji veidojas maināmas (custom) saskarnes un dziņus priekš katra aparatūras modeļa. Tas bija dārgi un dubulti darbietilpīgi. 90. gadu sākumā Silicon Graphics (SGI) bija vadošā kompānija, kas nodrošināja 3D grafiku darbstacijām. Tās veidotā IRIS GL lietojumprogrammas saskarne bija iecerēta kā "mākslas darbs" un kļuva par de facto industrijas standartu, aptumšojot atvērtos standartos bāzēto PHIGS. Tas izdevās pateicoties tam, ka IRIS GL bija vieglāk lietot, un arī tāpēc ka tā atbalstīja tūlītējā režīma (immediate mode) renderēšanu. Salīdzinājumam PHIGS bija grūti lietojams un no funkcionalitātes viedokļa novecojis. SGI konkurenti (ieskaitot Sun Microsystems, Hewlett-Packard un IBM) arī bija spējīgi tirgū piedāvāt 3D aparatūru, kurā bija atbalstīti ar PHIGS standartu savietojami standarti. Tas vājināja SGI tirgus daļu, kolīdz citi 3D aparatūras ražotāji ienāca tirgū. Cenšoties mainīt tirgu sev par labu, SGI pieņēma lēmumu IrisGL API izplatīt kā atvērto standartu. SGI secināja, ka IrisGL API nav piemērots atklātības principiem dažādu licenču un īpašniektiesību dēļ. Tāpat IrisGL nebija pilnība apmierinošs 3D grafikas vajadzībām. Un, proti, tajā bija tikai daļēji realizētas logošanas, tastatūras un peles lietojumprogrammu saskarnes, jo tās bija izstrādātas pirms parādījās pirmās X Window System un Sun NeWS izstrādes šajā virzienā. Piedevām, tā kā SGI bija ievērojams programmatūras klientu skaits, ar OpenGL lietojumprogrammatūras saskarnes piedāvāšanu tiem, bija iecerēts tos saglabāt kā SGI (un arī IBM) aparatūras lietotājus, līdz OpenGL lietojumprogrammatūras atbalsts nobriestu plašam tirgum. Un pa tam, SGI censtos noturēt savas aparatūras patērētājus, piedāvājot tiem modernās un patentētās Iris Inventor un Iris Performer programmējamās lietojumprogrammatūras saskarnes. Šo notikumu rezultātā, tapa SGI piedāvātais OpenGL standarts. OpenGL standartizēja piekļuvi pie aparatūras un aparatūras ražotāju, kā arī aizsāka aparatūras izstrādātāju vidū aparatūras saskarņu programmu izstrādes atbildības politiku, kā redzamākais ieguvums mūsdienās ir ierīces dzinis (device driver). Tāpat OpenGL deliģēja logošanas funkcijas operētājsistēmai. Spēja mijiedarboties ar tik plašu aparatūras klāstu, liekot tai visai "runāt vienā valodā", dāvāja programmatūras izstrādātājiem augstākā līmeņa platformu 3D programmatūras izstrādei. 1992. gadā, SGI nodibināja OpenGL architectural review board (OpenGL ARB) — kompāniju, kas nākamajos gados uzturēja un popularizēja OpenGL specifikācijas, grupas — izveides iniciators. OpenGL izveidojās (un būtībā bija ļoti tuvs) SGI agrākajai 3D saskarnei IrisGL. Viens no IrisGL ierobežojumiem bija, ka tas piedāvāji piekļuvi tikai pie tām iespējām, kas bija uzturētas aparatūrā. Ja grafikas aparatūra neatbalstīja iespēja, tad programma nespēja to izmantot. OpenGL atrisināja šo problēmu, piedāvājot iespējas, ko aparatūra neuzturēja, sniedzot iespēju programmai lietot modernas grafikas uz relatīvi zemas jaudas sistēmām. 1994 SGI nodevās iecerei par "OpenGL++", kurā bija iekļauti tādi elementi kā ainu grafu (scene-graph) saskarnes (jādomā veidotas uz viņu Performer tehnoloģijas bāzes). Specifikācijas tika prezentētas pāris izstrādātāju salidojumus, taču tā arī neguva plašāku popularitāti, tā arī nekļūstot par produktu. Microsoft prezentēja Direct3D 1995. gadā, un tas kļuva par galveno OpenGL konkurentu. 1997. gada 17. decembrī Microsoft un SGI aizsāka Fahrenheit projektu, kura mērķis bija apvienot OpenGL un Direct3D saskarnes. 1998. gadā projektā iesaistījās Hewlett-Packard. Projekts sākotnēji radīja cerību, ka 3D datorgrafikas saskarņu pasaulē būs kārtība, bet sakarā ar SGI finansiālām grūtībām, Microsoft stratēģiju, un vispārēju industrijas ignoranci, šis projekts tikai pārtraukts 1999. gadā. Salīdzinājumā ar DirectX, OpenGL tika kritizēts par apgrūtinošu Konsorcija darbību. Kritiķi uzsvēra, ka tajā ietilpstošais lielais uzņēmumu ar dažādām interesēm skaits noved pie ilgstoša jaunas versijas specifikācijas apstiprinājumu. OpenGL prezentēja 3Dlabs kā atbilde uztraukumam par lēnu izstrādi un nenoteiktu OpenGL nākotni. 3Dlabs piedāvāja vairākus būtiskus papildinājumus standartam, no kuriem ievērojamākais bija [GLSL] (OpenGL Shading Language). Tas programmētājam ļāva aizvietot fiksēto OpenGL konveijeri ar nelielām GLSL valodā rakstītām programmām, un tas ļāva realizēt tādus efektus kā, piemēram, reljefās tekstūras (bump mapping), viļņus un ūdens ņirbēšanu. OpenGL 2 fināla versijas specifikācija ietvēra GLSL atbalstu.[11] Arhivēts 2007. gada 2. aprīlī, Wayback Machine vietnē. Tomēr arī pirms GLSL iekļaušanas OpenGL standartā bija iespēja izveidot specifektus dažādās programmēšanas valodās: : assembler (paplašinājumi vertex_program, fragment_program) un Cg (NVidia C for Graphics). Diemžēl daudzi ierosinājumu aizvien nav realizēti OpenGL 2.0 versijā, lai gan daudzi no tiem ir pieejami kā paplašinājumi. 2006. gada 2. augustā tika prezentēta OpenGL 2.1 versija un tā bija atpakaļsavienojama ar iepriekšjiem OpenGL laidieniem. OpenGL 2.1 piedāvāja sekojošu funkcionaltāti: OpenGL Ēnošanas valodu (Shading Language) 1.20 (GLSL) Komandas, kas specificēja un pieprasīja nekvadrātiskus matricu veidojumus (non-square matrix uniforms) mijiedarbei ar OpenGL Shading Language Pikseļbufera objektus efektīvai attēlu pārraidi no un uz bufera objektiem ar šādu komandu palīdzību glTexImage2D un glReadPixels. Šī funkcionalitāte ir atkarīga no ARB_pixel_buffer_object paplašinājuma. sRGB tekstūru formāts. Šī funkcionalitāte ir atkarīga no EXT_texture_sRGB paplašinājuma. Jaunā OpenGL lietojumprogrammas saskarnes versija ir OpenGL 3.0, kurai ir piešķirts koda vārds Longs Peak. Sākotnēji to bija iecerēts pabeigt 2007. gada septembrī, taču Khronos group 30. oktobrī izplatīja ziņu, ka tās iekšienē ir pāris domstarpības attiecībā uz OpenGL funkcionalitāti un ka tā vēlas tās atrisināt pirms galīgā laidiena un ka šobrīd tā pārvērtē specifikāciju. Šo iemeslu dēļ laidiens tika atlikts uz 2008. gadu. Pēc šī paziņojuma publiskajā telpā nav bijis tālāko ziņu attiecībā uz laidiena datumu vai progresu (2008-05-09), kas kopienā izsauca neapmierinātību un liekas spekulācijas. Neskatoties uz visu iepriekšminēto, Nvidia pārstāvis un ilggadējs OpenGL atbalstītājs, Maikls Golds, pavēstīja, ka BoF at SIGGRAPH 2008 interešu grupas salidojumā, kas notiks no 11. līdz 15. augustam Losandželosā, BoF interešu grupā tiks prezentēta OpenGL 3.0 specifikācija. Šī specifikācijas prezentācija ļoti iespējams arī būs OpenGL jaunās versijas laidiens. 2008. gada 11. augustā visubeidzot tika prezentēta OpenGL 3 specifikācija tiesa, ar komentāru, ka nedz Intel, nedz AMD vai Nvidia grafisko karšu risinājumi vēl neatbalsta jauno specifikāciju un nav zināms, kad tā pilnvērtīgi tiks nodrošināta. OpenGL 3.0 ir pirmais būtiskais lietojumprogrammas saskarnes pārskats OpenGL dzīves ciklā. Šis laidiens sastāv no pilnībā pārskatīta OpenGL darbības modeļa — sākot no modeļu izveides principiem un beidzot ar ēnošanu (shader). Atpakaļsavienojamību nodrošina visu iepriekšējo lietojumuprogrammas saskarņu pieejamība jaunajā risinājumā. Nekāda jauna funkcionalitāte vecajām lietojumprogrammu saskarnēm vairs nav pievienota. OpenGL 3.0 lietojumprogrammas saskarne ir fundamentāli citādāka nekā iepriekšējiem laidieniem raksturīgā. Jebkura fiksētā funkcionalitāte, kurai OpenGL 2.1 nodrošināja ēnošanas saskarni, tagad ir aizstāta ar ēnošanas pieeju(shader-only approach). Lietojumprogrammas saskarne ir racionalizēta: tagad tā ir vienlīdz ērta programmu un implementāciju izstrādē. Būtiskākā atšķirība no lietojumprogrammas saskarnes viedokļa ir objektorientācija (reliance on objects). OpenGL 2.1 objektu modelis bija atkarīgs no OpenGL stāvokļorientētā (state-based) dizaina. Tādējādi, lai modificētu objektu vai lai to lietotu, bija nepieciešams to sasaistīt ar stāvokļu sistēmu (the state system), tad veikt modifikācijas stāvoklim vai izpildīt tos funkciju izsaukumus, kas nodrošina objekta sasaisti. Šāds darbības mehānisms apgrūtināja OpenGL implementāciju darbību, jo bija nepieciešams zināt, vai objekts ir saistīts lietošanai (object was being bound for use) vai modifikācijai. Tāpat, tāpēc ka vēsturiski OpenGL pamatā bija objektu modelis, objektiem bija jābūt mainīgiem. Un proti, objektu pamatstruktūra varēja mainīties jebkurā laikā, pat ja renderēšanas konveijers (rendering pipeline) asinhroni lietoja šo objektu. Tekstūrmodeli varēja pārdefinēt no 2D uz 3D. Tas paģērēja implementāciju spēju bāreņot (to orphan) iekšējos objektus, un šis process lieki sarežģīja iekšējo objektu pārvaldību. Jaunais, 3.0 objektu modelis likvidē abas šīs problēmas. Objekti, kas ir radīti, ir un paliek nemainīgi. 2D tekstūra ir 2D tekstūras objekts noteiktajā paplašinājumā un formātā uz mūžiem, lai arī, protams, tā var tikt iznīcināta vai arī tikta papildināta ar cita attēla datiem. Tas paģēr būtiskas daļas OpenGL lietojumprogrammas saskarnes daļas mainīšanu. Savukārt šī objektu modelī bāzētā izmaiņa ir būtisks solis prom no stāvoklī bāzētas sistēmas uz objektorientētu sistēmu. Objektu radīšana ir kļuvusi atomiska; viens funkcijas izsaukums rada pilnībā noformētu objektu. Objektu koplietošana renderēšanas kontekstu vidē (across rendering contexts) ir noteikta katra objekta līmenī (at the per-object level); tas implementācijai sniedz iespēju lietot virkņdrošus (thread-safe) funkcijas izsaukumus uz šiem objektiem. Atomiskā objekta radīšana ir iespējama pateicoties detalizēta tipa veidnes objekta radīšanai (a template object of a particular type). Veidnes objekti ir līdzīgi C valodā izmantotajiem heterogēnajiem apkopotajiem datu tipiem (structs), ar to atšķirību, ka tie var tikt paplašināti ar jauniem objektiem bez pārkompilācijas. Atribūti tiek uzstādīti veidnes objektā, kolīdz lauki heterogēnajiem apkopotajiem datu tipos var tikt uzstādīti. Pēc tam veidnes objekts tiek nodots atbilstošajai objekta radīšanas funkcijai kā detalizēts veidnes objekta tips. Objektu radīšana vienlaicīgi ir arī asinhrona. Implementācijai ir atļauts sākt objektu radīšanu citā virknē. Ar objektu saistītais lokālais identifikators (handle) paliek validēts arī tajā gadījumā, ja objekta radīšana nav pabeigta. Renderēšana var notikt ar objektiem, kas vēl nav radīti, pateicoties tam, ka OpenGL renderēšana ir asinhrons process. Funkcijām, kas tiek lietotas mainīgu objektu mainīga daudzuma modificēšanai, piemēram, attēla satura izmainīšanai, ir iespējams objektu apstrādāt kā parametru. Tas ir pilnībā pretēji OpenGL 2.1 stilam, kur objektam bija jābūt saistītam kontekstā, ja to grasījās modificēt vai tikai tam piekļūt. Objekti aizvien ir saistīti kontekstā, lai tos varētu nodot renderēšanai. Pirmais draiveris, kas atbalsta OpenGL 3.0 (tikai Windows videi) specifikācijas un izsaukumu vidi, ir Nvidia draiveris 177.89 galddatoriem ar GeForce 8000 sērijas vai jaunākās saimes kartēm: GeForce GTX 260, 280; Quadro FX 370, 570, 1700, 3700, 4600, 4700x2, 5600. Savukārt klēpjdatoriem tiek atbalstītas GeForce 8000 sērijas vai jaunākās saimes kartes: Quadro FX 360M, 370M, 570M, 770M, 1600M, 1700M, 2700M, 3600M, 3700M. Šis draiveris nodrošina pilnu OpenGL 3.0 un GLSL 1.30 īstenojumu, izņemot: Vienkanāla (RED) un divkanāla (RG) tekstūras, Dažādizmēra kadru bufera objektu pievienojumus (dažādformāta pievienojumi ir atbalstīti), Notīrītājbufera lietojumprogrammu saskarni, Bezlogu renderēšanas atbalstu, Ar tālākadresiju savienojamu kontekstu, Atkļūdošanas kontekstu. Jau tagad tiek spriests, kādu jaunu papildusfunkcionalitāti varētu pievienot nākamajām pēc OpenGL 3.0 versijām. Šis ir visticamākais scenārijs, jo tik ilgu laiku atliktajā OpenGL 3.0 laidienā visticamākais tiks iekļautas arī papildiespējas un atjauninājumi "Longs Peak reloaded" un "Mt Evans". Šis atjauninājums, ko iecerēts prezentēt 2-3 mēnešus pēc OpenGL 3.0 laidiena, būs saistīts ar to nenozīmīgu iespēju pievienojumu, kuras nebija izšķirošas OpenGL 3.0 laidienam. Šīs iespējas galvenokārt fokusēsies uz lietošanas ērtumu, tādējādi padarot lietojumprogrammas saskarnes izmantošanu komfortablāku, lai arī galvenajā laidienā dažas veiktspēju uzlabojošās iespējas jau būs iekļautas. Šis atjauninājums, ko prezentēs 3-5 mēnešus pēc OpenGL 3.0 laidiena, primāri būs atjauninājums, kurā būs ietverts modernas aparatūras iespējas atbalsts. Un tas sevī iekļaus ģeometrijas šeiderus, veselos skaitļus šeideros (integers in shaders), tekstūru masīvus un tūlītēju renderēšanu (instanced rendering). 2006. gadā nozīmīgākie OpenGL ARB Working Group biedri bija: Advanced Micro Devices (AMD) Apple Creative Labs Graphic Remedy Intel Corporation id Software NVIDIA Sony Computer Entertainment Sun Microsystems Texas Instruments Iepazīties ar pilnu projektu biedru struktūru — sponsoriem, ziedotājiem un akadēmiķiem — iespējams Khronos Group mājaslapā. Refrakcijas izmantojot programmējamos virsotņu šeiderus Perl OpenGL animētās tekstūras izmantojot kadru bufera objektus un virsotņu/fragmentu programmas paplašinājumus Nozīmīgākās spēles, kurās ir ietverts OpenGL renderētājs: America's Army Baldur's Gate 2 — pēc noklusējuma D3D Call of Duty City of Heroes City of Villains CodeRED: Alien Arena Counter-Strike (ne Counter-Strike: Source) Darwinia — pēc ielāpa uzstādīšanas pēc noklusējuma D3D Doom 3 Dwarf Fortress Earth 2150 Enemy Territory: Quake Wars Far Cry — pēc noklusējuma D3D Frets On Fire FlightGear Half-Life (ne Half-Life 2) Homeworld 2 Neverwinter Nights Penumbra: Overture Prey Quake series Rage Scorched3D Second Life Serious Sam Serious Sam 2 — pēc noklusējuma D3D Spring Starsiege: Tribes Star Wars Jedi Knight: Jedi Academy The Chronicles of Riddick: Escape from Butcher Bay Tux Racer Ultima IX: Ascension Unreal series Warcraft 3 — pēc noklusējuma D3D Windows vidē Wolfenstein: Enemy Territory World of Warcraft — pēc noklusējuma D3D Windows vidē Wurm Online X-Plane ARB (GPU asamblervaloda) — OpenGL zemākā līmeņa ēnošanas (shading) valoda GLSL — OpenGL augstākā līmeņa ēnošanas (shading) valoda Cg — Nvidia's ēnošanas (shading) valoda, kas darbojas ar OpenGL OpenGL ES — OpenGL iegultajām sistēmām (for embedded systems) OpenAL — The Open Audio Library — ar OpenGL savietojama bibliotēka OpenSL ES — Cita audio bibliotēka grafiskais konveijers GLUT — OpenGL utilītprogrammu rīkkopa. SDL — The Simple DirectMedia Layer. GLU — Papildus funkcijas OpenGL programmām. GLee — The OpenGL Easy Extension library. GLEW — The OpenGL Extension Wrangler Library. GLUI — darbvirsmas vides rīku kopa, kas veidota ar GLUT. GLFW — pārnesama struktūra (portable framework) OpenGL lietotņu izstrādei. Framebuffer Object — bezekrāna (off-screen) renderēšanas paplašinājums. GLM — GLSL specifikācijās bāzēta C++ matemātisko rīku kopa priekš OpenGL. Mesa 3D — OpenGL atklātā pirmkoda implementācija. Direct3D — OpenGL konkurents. VirtualGL «The OpenGL Graphics System Specification. Version 2.1». «IRIS GL, SGI's property». «Creation of the OpenGL ARB». Arhivēts no oriģināla, laiks: 2007. gada 22. februārī. Skatīts: 2008. gada 25. maijā. «End of OpenGL++». «Announcement of Fahrenheit». Arhivēts no oriģināla, laiks: 2007. gada 27. septembrī. Skatīts: 2007. gada 16. februārī. «Members of Fahrenheit. 1998.». Arhivēts no oriģināla, laiks: 2008. gada 15. janvārī. Skatīts: 2008. gada 25. maijā. «End of Fahrenheit». «OpenGL 2.1 Features». Arhivēts no oriģināla, laiks: 2008. gada 22. maijā. Skatīts: 2008. gada 25. maijā. «OpenGL ARB announces an update on OpenGL 3.0». 2007. gada 30. oktobris. Skatīts: 2007-10-31. «Discussion in the ARB's announcement thread, months later». 2008. gada 8. maijs. Skatīts: 2008-05-08. (angliski) Jaunumi par OpenGL 3.0 (angliski) Khronos grupa dara zināma OpenGL 3.0 specifikāciju, kas atbalsta jaunākās videokartes Arhivēts 2008. gada 13. augustā, Wayback Machine vietnē. (krieviski) JIr iznācis OpenGL 3.0 «OpenGL SIGGRAPH 2006 Birds of a Feather Presentation (PowerPoint documents)». Arhivēts no oriģināla, laiks: 2008. gada 4. jūnijā. Skatīts: 2008. gada 25. maijā. «OpenGL Pipeline Newsletter Vol.2, The New Object Model». «The OpenGL Pipeline Newsletter - Volume 003, Using the Longs Peak Object Model». «The OpenGL Pipeline Newsletter - Volume 003, Climbing OpenGL Longs Peak». Richard S. Wright, Benjamin Lipchak, Nicholas Haemel: OpenGL SuperBible: Comprehensive Tutorial and Reference, 4th Edition, Addison-Wesley, June 18 2007 Dave Shreiner, Mason Woo, Jackie Neider, Tom Davis: OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2.1, 6th Edition, Addison-Wesley, July 30 2007 Fosner, Ron: OpenGL Programming for Windows 95 and Windows NT, Addison Wesley Mark Kilgard: OpenGL for the X Window System, Addison-Wesley Eric Lengyel: The OpenGL Extensions Guide, Charles River Media OpenGL Architecture Review Board, et al: OpenGL Reference Manual: The Official Reference Document to OpenGL, Version 1.4, Addison-Wesley OpenGL Architecture Review Board, et al: OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2, Fifth Edition, Addison-Wesley Rost, Randi J.: OpenGL Shading Language, Addison-Wesley Latvijas spēļu izstrādātāju kopienas gameZ development network foruma sadaļa par OpenGL Indago Gamez pamācība darbā ar OpenGL OpenGL resurspunkts (krieviski) Resurspunkts OpenGL spēļu izstrādātājiem (krieviski) OpenGL vispārējais apraksts (krieviski) OpenGL grafiskā bibliotēka (metodisks mācību līdzeklis) (krieviski) OpenGL pamācību no NeHe tulkojums krieviski (krieviski) OpenGL pamācība (krieviski) Ievads iekš OpenGL (krieviski) OpenGL vs. Direct3D (krieviski) OpenGL grafiskā saskarne (krieviski) Oficiālā mājaslapa Arhivēts 2011. gada 26. februārī, Wayback Machine vietnē. (angliski) SGI OpenGL tīmekļa vietne (angliski) Khronos Group (angliski) NeHe pamācības, OpenGL pamācības (angliski) CodeSampler.com, OpenGL koda paraugi (angliski) myOS — Miniatūra OpenGL izstrādes sistēma & OpenGL demonstrācijas datnes (angliski) OpenGL vikipēdija (angliski) Fahrenheit in Microsoft (angliski) OpenGL programmēšanas rokasgrāmata tīmeklī (angliski) gDEBugger — OpenGL atkļūdotājs un profilētājs Windows un Linux (angliski) OpenGL un Glut pamācības (angliski) Kāpēc OpenGL 3 ir tik nozīmīgs? Arhivēts 2008. gada 4. jūnijā, Wayback Machine vietnē. (angliski) OpenGL 3.0 rēgs (angliski) OpenGL pamācības un izstrādes rīki (angliski)